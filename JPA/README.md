# JPA

자바 애플리케이션에 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스(라이브러리 x)<br>
JPA는 단순히 명세이기 떄문에 구현이 없다. 대부분 Interface, Enum, Exception, Annotation으로 이루어져 있다.

- 직접적인 SQL문을 사용하지 않고 자바 코드를 사용해서 DB에 접근하고 조작할 수 있는 기술이다

## 장단점

### 장점

1. 객체 지향적으로 데이터를 관리할 수 있기 떄문에 비즈니스 로직에 집중 할 수 있다.
2. 데이터 생성, 변경, 관리가 쉽다.
3. 로직을 쿼리에 집중하기 보다는 객체 자체에 집중할 수 있다.
4. 빠른 개발이 가능하다.

### 단점

1. 잘 이해하고 사용하지 않으면 데이터 손실이 일어날 수 있다.
2. 성능상 문제가 있을 수도 있다

- @EnableJpaRepositories: JpaRepository에 대한 설정 정보를 자동적으로 로딩하고 Repository 빈을 등록하는 역할을 한다

- Entity: JPA가 관리하는 클래스로, 해당 클래스를 Entity라고 부른다
  - 테이블에 대응하는 하나의 클래스
  - JPA를 사용하여 테이블과 매핑해야할 클래스는 반드시 @Entity를 선언해야 한다
- 특징
  - public, protected이여야 한다
  - JPA 스팩으로 규정되어 있다

## N to M

### One to One

일대일 관계

- 주 테이블이나 대상 테이블 중에 외래키를 넣을 테이블을 선택 가능하다
  - 주 테이블에 외래 키 저장
  - 대상 테이블에 외래 키 저장
- 외래 키에 데이터베이스 유니크 제약조건이 추가되야 일대일 관계가 된다

- 주 테이블에 외래키
  - 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 하다
  - 값이 없으면 외래 키에 NULL을 허용해야 한다.
    - DB에 치명적일 수 있다.
- 대싱 테이블에 외래키
  - 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지할 수 있다.
  - 코드 상에서 멤버 Entity에서 Locker를 많이 엑세스 하는데 강제로 양방향 매핑을 해야 한다.
  - 기본 프록시 기능의 한계도 Lazy 로딩으로 설정해도 Eager 로딩이 된다

### One to Many

일대다 관계

- "일"이 연관 관계의 주인이다.
- "일" 쪽에서 외래키를 관리하겠다는 의미이다.
- @OneToMany와 @JoinColumn을 통해서 관리한다.
- List<대상>을 통해서 데이터를 관리한다.
- 실질적으로 거의 사용하지 않는다.
- mappedBy를 통해서 어디에 매핑 되는지 확인

### Many to One

다대일 관계

- JPA에서 가장 많이 사용하고, 꼭 알아야 되는 다중성
- DB 설계상 일대다에서 다쪽에 외래키가 존재를 하게 된다
- 다 쪽에서 이미 연관관계의 주인이 되어 외래키를 관리하고 있다
- @JoinColumn을 통해서 외래키 확인

### Many to Many

다대다 관계

- 객체는 컬렉션을 사용해서 객체 2개를 다대다 관계로 가능하다
- 다대다 단방향
  - @JoinTable을 통해서 연결 할 수 있다.
- 다대다 양방향

  - mappedBy를 통해서 설정할 수 있다.

- 사실상 연결 테이블을 엔티티로 승격시켜준다.
- 그리고 일대다, 다대일 관계를 맺어주는 것이 좋다.

## Fetch Join

일반 Join

- 연관 Entitiy에 Join을 걸어도 실제 쿼리에서는 SELECT하는 Entitiy는 오직 JPQL에서 조회하는 주체가 되는 Entitiy만 조회하여 영속화
- 해당 Entity만 SELECT해서 영속화하기 때문에 데이터는 필요하지 않지만 연관 Entitiy가 검색조건에는 필요한 경우에 주로 사용

Fetch Join

- 조회의 주체가 되는 Entitiy이외에 Fetch Join이 걸린 연관 Entitiy도 함께 SELECT 하여 모두 영속화
- Fetch Join이 걸린 Entitiy 모두 영속화하기 때문에 FecthType이 Lazy인 Entity를 참조하더라도 이미 영속성 컨텍스트에 들어있기 때문에 따로 쿼리가 실행되지 않은 채로 N + 1문제가 해결됨

### N + 1 문제

연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 개수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다.

케이스

- fetchType.EAGER 변경 후 findAll()로 조회하는 경우
- fetchType.LAZY 변경 후 Loop으로 조회하는 경우

- JpaRepository에 정의한 인터페이스 메서드를 실행하면 JPA는 메서드 이름을 분석하여 JPQL을 생성하여 실행
- JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 한다.
- JPQL은 findAll()이란 메서드를 수행하였을 때 해당 엔티티를 조회하는 select \* from table쿼리만 실행
- 연관된 Entity 기준으로 퀴리를 조회하기 때문
- 연관된 엔티티가 필요한 경우, FetchType으로 지정한 시점에 조회를 별도로 호출하게 된다.

## Audit Log

생성일자, 수정일자, 생성자, 수정자 컬럼은 모든 테이블에 디폴트 값으로 들어 있다.

- 모든 테이블에서 디폴드 값으로 들어 있다.
- 도메인에도 항상 똑같은 컬럼이 존재한다.
- 생성자, 수정일자, 생성자, 수정자 컬럼에 값을 자동으로 넣어주는 기능

### 데이터 변경 시 알림

- @PostLoad: 해당 엔티티를 새로 불러오거나 refresh 한 이후.
- @PrePersist: 해당 엔티티를 저장하기 이전
- @PostPersist: 해당 엔티티를 저장한 이후
- @PreUpdate: 해당 엔티티를 업데이트 하기 이전
- @PostUpdate: 해당 엔티티를 업데이트 한 이후
- @PreRemove: 해당 엔티티를 삭제하기 이전
- @PostRemove: 해당 엔티티를 삭제한 이후
