# AKKA

JVM 상의 동시성 분산 어플리케이션을 단순화 하는 오픈 소스 툴킷

- 동시성을 위해 여러 프로그래밍 모델을 지원
- Java, .net Framework엣 사용가능

## 사용 이유

기존: 멀티코어를 사용하는 프로그램 속도는 프로그램 내부에 존재하는 순차적 부분이 사용하는 시간에 의해서 제한된다.

- 동시성 구현을 위해 Thread나 Task를 Executor Service에 제출하는 코드를 구성, 이를 실행하면 여러 개의 Thread가 동시에 작업을 한다.
- Thread나 Task를 사용하지 않는 순차적 작업을 진행하는 곳이 존재한다.
- 이러한 순차적인 작업의 시간 때문에 프로그램이 낼 수 있는 속도의 최대치는 정해진다.

- Akka는 곳곳에 존재하는 순차적인 부분을 전부 없애거나 최소한으로 만들어서 사용한다.

- 자원을 효율적으로 활용하며 애플리케이션이 커져도 복잡도를 상대적으로 낮게 유지할 수 있다.

### 목적

- 클라우드에 배포하거나 다중 코어 장치에서 실행할 애플리케이션을 쉽게 구축
- 다중 코어 또는 분산 시스템의 가용 계산 능력을 최대한으로 활용

## 기술

1. Actor

- 배포, 동시성, 병렬성을 위해 단순하고 높은 수준의 추상화를 제공
- 비동기식, 비차단식, 고성능 메시지 기반의 프로그래밍 모델
- 매우 가벼운 이벤트 기반의 프로세스

2. Fault Tolerance (내결함성)

- "let-it-crash" 의미가 있는 감독 계층 구조를 가진다
- Actor 시스템은 여러 JVM을 포괄해서 내결함성 시스템을 제공할 수 있다.
- 스스로 문제를 해결하고, 멈추지 않는 내결함성이 높은 시스템을 작성하는데 유리하다.

3. Location Transparency (위치 투명성)

- Akka의 모든 것은 분산 환경에서 작동하도록 설계 되어 있다.
- Actor의 모든 상호작용은 순수한 메시지 전달을 사용하며, 모든 것이 비동기적이다.

4. Persistence (지속성)

- Actor가 경험하는 상태 변경은 Actor은 시작하거나 다시 시작할 때 지속할 수 있다.
- JVM이 충돌하거나 다른 노드로 마이그레이션된 경우에도 행위자가 자신의 상태를 복구할 수 있다.

### Actor

- 네트워크 연결
- 스케쥴링
- 클라스트 만드는 등

- 액테 기반의 애플리케이션 개발과 이에 필요한 추가 도구를 자연스럽게 지원

- Actor는 메시지를 받기 전 까지 아무 일도 수행하지 않는다.

메시지: 생성된 다음에는 변경될 수 없는 간단한 데이터 구조 (불변)

- 엑터는 한 번에 하나의 메시지를 받을 수 있다.
- 대기열과 다르게 메시지를 보낼 수 있다.

- 모든 것은 비동기적 실행 가능
  - 응답을 기다리지 않고 액테에게 메시지를 보낼 수 있다.
  - 스레드와는 다르지만, 엑터에 전달한 메시지는 언젠가는 스레드를 거쳐서 들어간다.

중요 특징

- 메시지를 보내고 받음으로써 애플리케이션을 만들 수 있다.
- 메시지는 로컬 기계의 사용 가능한 스레드 중 하나에서 처리될 수 있고 다른 서버에서 원격으로 처리될 수 있다.
- 메시지를 처리하는 위치와 액터가 실행되는 정확한 위치는 나중에 결정할 수 있다.
- 네트워크로 연결된 서비스와 비슷하지만 자원 사용량과 관리 오버헤드가 아주 작게 줄어든 작은 부품들로 애플리케이션을 만들 수 있다.

## 접근 방법 차이

- 전통적인 접근 방법: 데이터베이스에 의존하는 간단한 인-메모리 애프리케이션에서 시작
  - 인 메모리: 디스크가 아닌 주 메모리에 모든 데이터를 보유하고 있는 데이터베이스
- 애플리케이션의 상호 작용성 높이려면 -> 데이터베이스 폴링
- 네트워크 서비스를 추가하게 되면 RPC 기반의 네트워크와 데이터베이스를 함께 다루게 되어 복잡도가 눈에 띄게 증가한다
-
- 아카로 애플리케이션을 한번 만 작성하면 애플리케이션의 규모를 요구에 맞춰 확장하고 그에 따른 동시성 문제를 해결

|                         | 전통적인 접근 방법                                                          | 아카의 접근 방법                                                                |
| ----------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| 규모 확장               | 스레드, 데이터베이스로 변경할 수 있는 상태를 공유(CRUD), 웹 서비스 RPC 호출 | 메시지를 주고 받을 수 있는 액터, 공유하는 상태 없음, 변경할 수 없는 이벤트 기록 |
| 상요 작용하는 정보 제공 | 현재 정보를 폴링해서 가져옴                                                 | 이벤트 기반: 이벤트 발생 시 푸시(Push)                                          |
| 네트워크로 확장하기     | 동기 RPC, 블로킹 I/O                                                        | 비동기 메시지, 논 블로킹 I/O                                                    |
| 실패처리                | 모든 예외를 처리한다, 동작 잘 될 때만 진행                                  | 문제 발생시 (그 부분만) 중단, 실패한 부분을 격리 시키고 나머지 부분을 계속 진행 |

## 전통적인 규모 확장 VS 아카를 사용한 규모 확장

|                                                                | 전통적인 접근 방법                                                                           | 아카의 접근 방법                                                                                                  |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 애플리케이션 재시작하거나 중단되도 대화 데이터 망가지지 않도록 | 코드를 DAO로 작성, 데이터베이스만 변경 가능한 상태로 공유, 다른 부분은 CRUD를 모두 DB에 의존 | 메모리에 상태를 유지, 상태가 변경되면 로그에 저장, 재시작할때만 로그를 읽기                                       |
| 상호 작용하는 기능 제공                                        | 데이터베이스를 폴링, 폴링하면 변경없을 때도 자원 소비                                        | 관심 있는 부분을 이벤트로 푸시, 중요 이벤트가 있을 때만 객체가 상대방에게 통지 , 부가 비용 감소                   |
| 서비스 분리                                                    | 비동기 처리를 위해 메시지 큐를 추가                                                          | 비동기적 메시지 큐에 추가 X, 메시지를 전송, 수신은 이미 구현되어서 복잡도가 커지지 않는다                         |
| 필수 적인 서비스가 실패, 요구 사항을 벗어난 행동               | 모든 실패 시나리오를 예측하고 예외를 잡아 낸다                                               | 메시지를 비동기 적으로 보내므로 문제가 생긴 컴포넌트가 메시지를 처리 못하더라도 컴포넌트의 안정성에는 영향이 없다 |

- 코드를 단 한 번 작성하고 원하는 대로 규모 확장을 처리해 준다면 가장 좋다
- 애플리케이션의 주 객체를 뜯어 고치는 일을 피하고 싶다
- 인-메모리 객체에 들어있던 모든 로직을 DAO로 옮겨야만 했다
  목표
- 대화 데이터를 안전하게 유지
  - 데이터베이스로 대화 데이터를 옮기는 바람에 애플리케이션도 간단한 인메모리 모델에서 멀어진다
  - 모든 구조를 단순하게 유지하면서도 대화 데이터를 안전하게 보장할 수 있는 방법을 찾아야 된다

### 메시지 송수신

오직 복구할 때만 데이터베이스를 사용한다

- Actor는 메시지를 로그에 보내고 애플리케이션을 다시 시작할 때 로그에서 메시지를 다시 받는다

- 이벤트를 발생 순서 그대로 Replay 함으로써 메시지를 복구 할 수 있다.

변경 사항을 이벤트 시퀀스로 유지함

- 메모리에 발생했던 모든 이벤트를 리플레이 하면 현재 상태를 다시 구성할 수 있다.
- 대화가 중단된 시점부터 다시 시작할 수 있다.

- 저널: 모든 이벤트를 순서대로 저장하는 것과 저장했던 순서 그대로 이벤트를 다시 불러오는 것뿐

데이터 전파하기: 대화의 공유

- 서버를 샤닝 또는 파티셔닝

### 푸시 메시지

- 사용자 마다 데이터베이스를 폴링하는 대신, 웹 브라우저로 직접 메시지를 보내서 이벤트를 통지할 방법을 찾는다

## 액터

한 가지 프로그래밍 모델로 수직/수평 확장을 동시에 할 수 있다

- 병렬성: 프로세스를 동시에 실행하는 것이 문제
- 동시성: 동시에 가능할 수 있는 프로세스를 정의하는데 관심

JVM: 표준 동시성 프로그래밍 모델

- 프로세스: 객체와 메서드로 표현, 메서드는 스레드에서 실행
- 여러 CPU에서 병렬로 실행될 수도 있고, 타임 슬라이싱과 같은 공유 기법을 활용해서 한 CPU에서만 실행 될 수도 있다.

### 비동기 모델

비동기적: 애플리케이션의 규모를 여러 서버에 걸쳐 키우려 한다면 프로그래밍 모델에 중요한 요구사항

- 컴포넌트가 다른 컴포넌트의 응답을 아직 받지 못했을 때도 계속해서 필요한 일을 수행할 수 있어야 한다

### 액터 연산

생성(Create), 송신(Send), 상태 변화(Become), 감독(Supervise)이라는 네 가지 핵심 연산만을 제공하는 경량 프로세스

- 모든 연산은 비동기적이다

송신

- 다른 액터와 의사소통 하는 방법은 오직 메시지를 보내는 방법
- 오간 메시지 목록을 공유하거나 어떤 시점이 동시에 그런 대화를 변경하는 일은 없다
- 발사 후 망각 스타일로 이루어 진다: (메시지가 알아서 처리가 된다)
- 다른 액터가 메시지를 받았는지 꼭 알아야 한다면 메시지를 받은 액터가 송신 통지 메시지를 다시 보내주면 된다

- 송신 액터와 수신 액터 사이에는 전송된 메시지의 순서가 유지된다
- 액터는 메시지를 한 번에 하나씩만 받는다

생성

- 액터는 다른 액터를 생성할 수 있다.
  - 액터는 계층 구조로 이루어져 있다.

상태 변화

- 어떤 시스템이 특정 상태에 있을 때만 수행하도록 보장하고 싶을 때 사용
- 하나의 메시지를 받기 때문에 편리한 특성이다
- 메시지를 처리하는 방법을 바꾸고 싶을 때는 행동 양식을 변경한다

감독

- 자신이 맏는 다른 액터를 감독한다
- 주요 컴포넌트에 무슨 일이 벌어지는지를 추적한다
- Supervisor는 시스템의 컴포넌트가 실패했을 때 해야 할 일을 결정한다
- 특별한 메시지를 통해 어떤 액터가 왜 중단 됐는지 통지를 받는다
- 어떤 액터든지 Supervisor가 될 수 있다
  - 하지만 자신이 직접 만든 액터에 대해서 만 가능

디커플링

- 공간: 액터는 다른 액터의 위치에 대해 아무것도 보장받지 못하고 아무 것도 예상할 수 없다
- 시간: 액터는 자신의 작업이 언제 끝날지 아무 것보 보장받지 못하고 아무 것도 예상할 수 없다
- 인터페이스: 액터는 아무 인테페이스를 정의하지 않는다, 액터는 다른 컴포넌트가 어떤 메시지를 이해할 수 있는 지를 예상할 수 없다
  - 액터는 변경 가능한 어떤 공유 정보도 가리키거나 사용해서는 안된다, 오직 메시지를 통해서만 전달 된다
