# AKKA

JVM 상의 동시성 분산 어플리케이션을 단순화 하는 오픈 소스 툴킷

- 동시성, 확장 가능성, 회복력이 잇는 반응형 애플리케이션

- 동시성을 위해 여러 프로그래밍 모델을 지원
- Java, .net Framework엣 사용가능

## 추가

SBT: Simple Build Tool

- 스칼라로 작성되었고 스칼라에 사용하기 편한 기능들

1. 건전한 의존성 관리
2. 태스크를 작성할 수 있는 스칼라 언어 전체를 지원
3. 연속으로 명령 실행
4. 프로젝트 문맥하에 REPL 실행가능

## 사용 이유

기존: 멀티코어를 사용하는 프로그램 속도는 프로그램 내부에 존재하는 순차적 부분이 사용하는 시간에 의해서 제한된다.

- 동시성 구현을 위해 Thread나 Task를 Executor Service에 제출하는 코드를 구성, 이를 실행하면 여러 개의 Thread가 동시에 작업을 한다.
- Thread나 Task를 사용하지 않는 순차적 작업을 진행하는 곳이 존재한다.
- 이러한 순차적인 작업의 시간 때문에 프로그램이 낼 수 있는 속도의 최대치는 정해진다.

- Akka는 곳곳에 존재하는 순차적인 부분을 전부 없애거나 최소한으로 만들어서 사용한다.

- 자원을 효율적으로 활용하며 애플리케이션이 커져도 복잡도를 상대적으로 낮게 유지할 수 있다.

### 암달의 법칙

- 비동기 처리를 하기 위해서 이지만 기본 init, DB 저장은 기본적으로 모두 처음, 마지막에 공통적으로 일어나야 된다.
- AKKA는 순차적으로 존재하는 것들을 최소한으로 줄이는 것이다

### 가장 큰 이유

- API: Method는 동기
- AKKA: Actor는 비동기
- 비동기 이므로 컴퓨터 자원과 스레드를 더 효율적으로 사용할 수 있다.

### 목적

- 클라우드에 배포하거나 다중 코어 장치에서 실행할 애플리케이션을 쉽게 구축
- 다중 코어 또는 분산 시스템의 가용 계산 능력을 최대한으로 활용

### 특징

1. 다른 액터에 한정된 개수의 메시지를 보낼 수 있다.
2. 유한한 개수의 액터를 만들어낼 수 있다.
3. 다른 액터가 받을 메시지에 수반될 행동을 지정할 수 있다.
4. 이러한 모든 일이 동시적으로 일어난다

## 기술

1. Actor

- 배포, 동시성, 병렬성을 위해 단순하고 높은 수준의 추상화를 제공
- 비동기식, 비차단식, 고성능 메시지 기반의 프로그래밍 모델
- 매우 가벼운 이벤트 기반의 프로세스

2. Fault Tolerance (내결함성)

- "let-it-crash" 의미가 있는 감독 계층 구조를 가진다
- Actor 시스템은 여러 JVM을 포괄해서 내결함성 시스템을 제공할 수 있다.
- 스스로 문제를 해결하고, 멈추지 않는 내결함성이 높은 시스템을 작성하는데 유리하다.

3. Location Transparency (위치 투명성)

- Akka의 모든 것은 분산 환경에서 작동하도록 설계 되어 있다.
- Actor의 모든 상호작용은 순수한 메시지 전달을 사용하며, 모든 것이 비동기적이다.

4. Persistence (지속성)

- Actor가 경험하는 상태 변경은 Actor은 시작하거나 다시 시작할 때 지속할 수 있다.
- JVM이 충돌하거나 다른 노드로 마이그레이션된 경우에도 행위자가 자신의 상태를 복구할 수 있다.

### Actor

- 네트워크 연결
- 스케쥴링
- 클라스트 만드는 등

- 액테 기반의 애플리케이션 개발과 이에 필요한 추가 도구를 자연스럽게 지원

- Actor는 메시지를 받기 전 까지 아무 일도 수행하지 않는다.

메시지: 생성된 다음에는 변경될 수 없는 간단한 데이터 구조 (불변)

- 엑터는 한 번에 하나의 메시지를 받을 수 있다.
- 대기열과 다르게 메시지를 보낼 수 있다.

- 모든 것은 비동기적 실행 가능
  - 응답을 기다리지 않고 액테에게 메시지를 보낼 수 있다.
  - 스레드와는 다르지만, 엑터에 전달한 메시지는 언젠가는 스레드를 거쳐서 들어간다.

중요 특징

- 메시지를 보내고 받음으로써 애플리케이션을 만들 수 있다.
- 메시지는 로컬 기계의 사용 가능한 스레드 중 하나에서 처리될 수 있고 다른 서버에서 원격으로 처리될 수 있다.
- 메시지를 처리하는 위치와 액터가 실행되는 정확한 위치는 나중에 결정할 수 있다.
- 네트워크로 연결된 서비스와 비슷하지만 자원 사용량과 관리 오버헤드가 아주 작게 줄어든 작은 부품들로 애플리케이션을 만들 수 있다.

### Actor의 속성

1. 상태(State): 액터는 내부 상태가 있고, 이 상태는 메시지를 처리함에 따라 순차적으로 변한다
2. 행위(Behavior): 액터는 송신된 메시지에 행위를 적용함으로써 반응한다.
3. 통신(Communication): 액터는 다른 액터에게 메시지를 송신하거나 수신함으로써 서로 통신한다.
4. 메일박스(Mailbox): 메일 박스는 액터가 메시지를 가져오고 처리하는 메시지 큐

액터는 메시지 기반으로 수동적이며 사용자가 메시지를 보내지 않는 한 그리고 보낼 때 까지 아무것도 하지 않는다

- 메시지를 보내면 액터는 디스패치(Dispatcher)라 알려진 스레드 풀에서 가져와서 메시지를 처리하고, 스레드를 스레드 풀로 다시 해제시킨다
- 액터는 또한 본래 비동기적이다. 절대로 현재 실행 스레드를 막지 않는다.

## 접근 방법 차이

- 전통적인 접근 방법: 데이터베이스에 의존하는 간단한 인-메모리 애프리케이션에서 시작
  - 인 메모리: 디스크가 아닌 주 메모리에 모든 데이터를 보유하고 있는 데이터베이스
- 애플리케이션의 상호 작용성 높이려면 -> 데이터베이스 폴링
- 네트워크 서비스를 추가하게 되면 RPC 기반의 네트워크와 데이터베이스를 함께 다루게 되어 복잡도가 눈에 띄게 증가한다
-
- 아카로 애플리케이션을 한번 만 작성하면 애플리케이션의 규모를 요구에 맞춰 확장하고 그에 따른 동시성 문제를 해결

|                         | 전통적인 접근 방법                                                          | 아카의 접근 방법                                                                |
| ----------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| 규모 확장               | 스레드, 데이터베이스로 변경할 수 있는 상태를 공유(CRUD), 웹 서비스 RPC 호출 | 메시지를 주고 받을 수 있는 액터, 공유하는 상태 없음, 변경할 수 없는 이벤트 기록 |
| 상요 작용하는 정보 제공 | 현재 정보를 폴링해서 가져옴                                                 | 이벤트 기반: 이벤트 발생 시 푸시(Push)                                          |
| 네트워크로 확장하기     | 동기 RPC, 블로킹 I/O                                                        | 비동기 메시지, 논 블로킹 I/O                                                    |
| 실패처리                | 모든 예외를 처리한다, 동작 잘 될 때만 진행                                  | 문제 발생시 (그 부분만) 중단, 실패한 부분을 격리 시키고 나머지 부분을 계속 진행 |

## 전통적인 규모 확장 VS 아카를 사용한 규모 확장

|                                                                | 전통적인 접근 방법                                                                           | 아카의 접근 방법                                                                                                  |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 애플리케이션 재시작하거나 중단되도 대화 데이터 망가지지 않도록 | 코드를 DAO로 작성, 데이터베이스만 변경 가능한 상태로 공유, 다른 부분은 CRUD를 모두 DB에 의존 | 메모리에 상태를 유지, 상태가 변경되면 로그에 저장, 재시작할때만 로그를 읽기                                       |
| 상호 작용하는 기능 제공                                        | 데이터베이스를 폴링, 폴링하면 변경없을 때도 자원 소비                                        | 관심 있는 부분을 이벤트로 푸시, 중요 이벤트가 있을 때만 객체가 상대방에게 통지 , 부가 비용 감소                   |
| 서비스 분리                                                    | 비동기 처리를 위해 메시지 큐를 추가                                                          | 비동기적 메시지 큐에 추가 X, 메시지를 전송, 수신은 이미 구현되어서 복잡도가 커지지 않는다                         |
| 필수 적인 서비스가 실패, 요구 사항을 벗어난 행동               | 모든 실패 시나리오를 예측하고 예외를 잡아 낸다                                               | 메시지를 비동기 적으로 보내므로 문제가 생긴 컴포넌트가 메시지를 처리 못하더라도 컴포넌트의 안정성에는 영향이 없다 |

- 코드를 단 한 번 작성하고 원하는 대로 규모 확장을 처리해 준다면 가장 좋다
- 애플리케이션의 주 객체를 뜯어 고치는 일을 피하고 싶다
- 인-메모리 객체에 들어있던 모든 로직을 DAO로 옮겨야만 했다
  목표
- 대화 데이터를 안전하게 유지
  - 데이터베이스로 대화 데이터를 옮기는 바람에 애플리케이션도 간단한 인메모리 모델에서 멀어진다
  - 모든 구조를 단순하게 유지하면서도 대화 데이터를 안전하게 보장할 수 있는 방법을 찾아야 된다

### 메시지 송수신

오직 복구할 때만 데이터베이스를 사용한다

- Actor는 메시지를 로그에 보내고 애플리케이션을 다시 시작할 때 로그에서 메시지를 다시 받는다

- 이벤트를 발생 순서 그대로 Replay 함으로써 메시지를 복구 할 수 있다.

변경 사항을 이벤트 시퀀스로 유지함

- 메모리에 발생했던 모든 이벤트를 리플레이 하면 현재 상태를 다시 구성할 수 있다.
- 대화가 중단된 시점부터 다시 시작할 수 있다.

- 저널: 모든 이벤트를 순서대로 저장하는 것과 저장했던 순서 그대로 이벤트를 다시 불러오는 것뿐

데이터 전파하기: 대화의 공유

- 서버를 샤닝 또는 파티셔닝

### 푸시 메시지

- 사용자 마다 데이터베이스를 폴링하는 대신, 웹 브라우저로 직접 메시지를 보내서 이벤트를 통지할 방법을 찾는다

## 액터

한 가지 프로그래밍 모델로 수직/수평 확장을 동시에 할 수 있다

- 병렬성: 프로세스를 동시에 실행하는 것이 문제
- 동시성: 동시에 가능할 수 있는 프로세스를 정의하는데 관심

JVM: 표준 동시성 프로그래밍 모델

- 프로세스: 객체와 메서드로 표현, 메서드는 스레드에서 실행
- 여러 CPU에서 병렬로 실행될 수도 있고, 타임 슬라이싱과 같은 공유 기법을 활용해서 한 CPU에서만 실행 될 수도 있다.

### 비동기 모델

비동기적: 애플리케이션의 규모를 여러 서버에 걸쳐 키우려 한다면 프로그래밍 모델에 중요한 요구사항

- 컴포넌트가 다른 컴포넌트의 응답을 아직 받지 못했을 때도 계속해서 필요한 일을 수행할 수 있어야 한다

### 액터 연산

생성(Create), 송신(Send), 상태 변화(Become), 감독(Supervise)이라는 네 가지 핵심 연산만을 제공하는 경량 프로세스

- 모든 연산은 비동기적이다

송신

- 다른 액터와 의사소통 하는 방법은 오직 메시지를 보내는 방법
- 오간 메시지 목록을 공유하거나 어떤 시점이 동시에 그런 대화를 변경하는 일은 없다
- 발사 후 망각 스타일로 이루어 진다: (메시지가 알아서 처리가 된다)
- 다른 액터가 메시지를 받았는지 꼭 알아야 한다면 메시지를 받은 액터가 송신 통지 메시지를 다시 보내주면 된다

- 송신 액터와 수신 액터 사이에는 전송된 메시지의 순서가 유지된다
- 액터는 메시지를 한 번에 하나씩만 받는다

생성

- 액터는 다른 액터를 생성할 수 있다.
  - 액터는 계층 구조로 이루어져 있다.

상태 변화

- 어떤 시스템이 특정 상태에 있을 때만 수행하도록 보장하고 싶을 때 사용
- 하나의 메시지를 받기 때문에 편리한 특성이다
- 메시지를 처리하는 방법을 바꾸고 싶을 때는 행동 양식을 변경한다

감독

- 자신이 맏는 다른 액터를 감독한다
- 주요 컴포넌트에 무슨 일이 벌어지는지를 추적한다
- Supervisor는 시스템의 컴포넌트가 실패했을 때 해야 할 일을 결정한다
- 특별한 메시지를 통해 어떤 액터가 왜 중단 됐는지 통지를 받는다
- 어떤 액터든지 Supervisor가 될 수 있다
  - 하지만 자신이 직접 만든 액터에 대해서 만 가능

디커플링

- 공간: 액터는 다른 액터의 위치에 대해 아무것도 보장받지 못하고 아무 것도 예상할 수 없다
- 시간: 액터는 자신의 작업이 언제 끝날지 아무 것보 보장받지 못하고 아무 것도 예상할 수 없다
- 인터페이스: 액터는 아무 인테페이스를 정의하지 않는다, 액터는 다른 컴포넌트가 어떤 메시지를 이해할 수 있는 지를 예상할 수 없다
  - 액터는 변경 가능한 어떤 공유 정보도 가리키거나 사용해서는 안된다, 오직 메시지를 통해서만 전달 된다

## 아카 액터

### ActorSystem

actor를 내부에서 생성하고 동작하게 담고 잇는 컨테이너, 하나의 ActorSystem은 같은 JVM에서 돌아간다

- 최초의 액터는 Supervisor, 모든 액터는 같은 애플리케이션의 일부분 이다
- 모든 아카 애플리케이션이 반드시 맨 처음 해야 되는 것은 ActorSystem을 만드는 것이다
- Actor 시스템은 최상위 ActorSystem을 만드는 것이다
- 모든 액터 위에 최상위 액터를 오직 하나만 만드는 것이 일반적인 패턴이다

- ActorSystem은 만들어진 액터를 자체 반환하지 않고 액터에 대한 주소를 반환한다. (ActorRef)
- 액터에게 메시지를 보내려면 ActorRef를 사용해야 한다
- 액터 시스템에서 액터를 찾아야 할 필요가 있을 때 (ActorPㅁth)
- 모든 액터에는 이름이 있고 같은 계층 내에서 유일해야 한다
  상대적이거나 절대적인 경로를 사용하면 어떤 액터 참조(ActorRef)든 바로 찾을 수 있다

### ActorRef, 우편함, 액터

- 메시지는 액터의 ActorRef로 보내진다
- 모든 액터에는 우편함이 있다 (큐와 비슷)
- 한 번에 하나씩 우편함을 도착한 순서대로 메시지를 처리한다
- Actor의 주소를 담고 있는 데이터형이다
- Actor는 해당 객체로 접근하여 해당 actor의 주소로 서로의 메시지를 던져서 해당 함수를 호출한다
- Actor의 주소를 담고 있는 데이터 형이다: 해당 객체로 접근하여 public Method를 쓰는 구조가 아니라 해당 Actor의 주소로 서로 메시지를 던져서 해당 함수를 호출한다.

### Props

- Actor에 구현 클래스와 해당 구현클래스의 생성자에 필요한 매개변수를 주입하기 위한 객체

### ActorContext

- 해당 액터의 관점에서 보는 ActorSystem의 모습을 나타내는 객체
- 해당 Context에서 Actor를 생성하면 ActorSystem안에 같이 있지만 자신을 기준으로 생성되어 자식이 되는 것

```Java
//  actorSystem에서 actorOf라는 함수를 사용해 actor를 생성한다.
// 첫 번째 매개변수는 Props, 두 번째 매개변수는 actor 이름이 들어간다.
public class Main{
  public static void main(String[] args){
    ActorSystem actorSystem = ActorSystem.create("TestSystem");
    ActorRef helloWorld = actorSystem.actorOf(Props.create(HelloWorld.class), "helloWorldActor")
  }
}

public class HelloWorld extends UpTypedActor{
  public HelloWorld(){
    ActorRef child = context().actorOf(Props.create(HelloChild.class), "helloChildActor");
  }
}
```

helloChildActor는 helloWorldActor의 자식이 되어 이 둘의 생명 주기를 같이 한다.

### 디스패처

디스패처가 우편함에 있는 메시지를 액터에게 푸시한다

- 메시지를 전달 받을 때 사용할 스레딩 모델을 통해서 유형을 결정한다
- 디스패처를 액터 하나에만 할당하거나, 몇몇 액터가 모인 그룹에 할당하거나, 시스템에 있는 모든 액터에 할당할 수 있다.

- 1GB 메모리에 2_700_000개의 액터를 넣을 수 있다
- 1GB에 4_096개밖에 못들어 가는 스레드와 비교하면 차이가 크다

### Provider

- 원격 객체처리를 위한 원격처리 모듈을 어떤 걸로 쓸지 정할 수 지정을 할 수 있다 (현재 기준 기본 값)
- 원격지 RemoteActorRefProvider를 통해 actorRef를 사용할 수 있다.

## Cluster

- 클러스터는 단일 실패 지점이나 병목현상이 없는 Akka.NET 애플리케이션의 내결함성, 탄력적, 분산형, Peer to peer 네트워크를 나타낸다.
- Akka.Cluster는 애플리케이션을 생성할 수 있는 기능을 제공하는 모듈

### 사용하는 이유

노드를 확장하기 위해 노드를 추가하고, 기존 노드에 신규 노드에 대한 서설정을 셋팅한 후에 그 설정을 적용하기 위해 전체 서비스를 재시작하거나 잘 작동하는 서비스의 리로드가 필요했다.

### Cluster 역할

1. Akka.NET 애플리케이션의 P2P 네트워크를 쉽게 만들 수 있다.
2. 피어 구성 변경없이 자동으로 새 노드를 검색, 죽은 노드를 자동으로 제거
3. 사용자 정의 클래스가 클러스터의 노드 가용성 변경에 대한 알림을 구독할 수 있다.
4. 클러스터 내에서 서로 다른 Akka.NET 애플리케이션을 구별하기 위한 역할 개념 도입
5. 클러스터형 라우터가 노드 가용성에 따라 경로 목록을 자동으로 조정한다는 점을 제외하고 기본 제공 Akka.NET 라우터의 확장인 클러스터형 라우터를 생성할 수 있다.

### 클러스터 상태 변경

1. 초기 클러스터 상태

- A, B 모두 시드 노드, C,D,E 구성으로 주어진 IP 주소/포트 조합에서 수신 대기
- A와 B는 또한 서로의 위치를 알고 있으므로 초기 서로 통신 가능

2. 상태 1 - 클러스터 가입

- 모든 노드는 초기에 시드 노드에 연결을 시도한다.
  - E는 B에게 연락하는 방법을 안다
  - C와 D는 A에게 연락하는 방법을 안다.
  - A와 B는 서로 연락하는 방법을 안다

3. 상태 2 - 리더 선택, 노드 표시

- 클러스터 내에서 초기 접촉 과정에서 리더가 선출이 된다
- A는 A,B,C 및 D에 대해 알고 있는 노드부터 노드를 Up으로 표시하기 시작한다
- A는 아직도 노드 E에 대해 모르기 때문에 up으로 표시하지 않는다.
- 클러스터 구성원 자격에 대한 Gossip 정보가 모든 노드가 퍼지기 시작하고, 모든 노드가 서로 연결하여 메쉬 네트워크를 형성

4. 상태 3 - Gossip 퍼지고, Ring 형성

- Gossip 이 모든 노드에 전파되고 지시선이 모든 노드를 Up으로 표시한 후, 모든 노드가 다른 모든 노드에 연결되고 클러스터가 형성된다.

### 시드 노드

- akka Cluseter의 진입점
- Seed Node 중 첫 번째 Seed Node가 중요하다
- AKKA Cluster가 처음 시작될 때에는 첫번째 Seed Node는 작동되고 있는 (started) node의 주소로 할당한다.
- 시작하는 Node와 첫번째 seed Node가 같을 경우 Akka Cluster가 새롭게 생긴다.

### 액터와 네트워크

ActorRef는 근본적으로 액터의 주소

- 실제 액터와 연관 시키는 방법만 바꾸면 문제가 해결된다
- 주소 해석 부분만 설정만 변경하면 전체 애플리케이션의 규모를 확장할 수 있다.

## 내용 정리

- 액터: 수직과 수평 규모 확장을 위한 프로그래밍 모델
- 한가지 프로그래밍 모델만으로 작업할 수 있다는 사실 덕분에 규모 확장 시 발생할 수 있는 복잡도 중 많은 부분이 줄어든다

## 장애 허용

- 시스템의 속성으로, 장애 시 완전히 고장 나기보다는 항상 반응성을 유지하려 하는 것을 말한다.
- 이런 시스템은 장애 허용 시스템이나 회복력 있는 시스템으로 알려져 있다

- 장애 허용 시스템은 완전히 가동 중일 때 보다 더 아니면 덜 가동되려 하는 시스템으로, 컴포넌트의 부분적인 장애로 인해 어쩌면 처리량의 감소나 응답 시간의 연장을 야기할 수 있다.

- 분산 시스템을 디자인 할 때 하나나 그 이상의 컴포넌트가 중단될 때 무순 일이 벌어지는지 신경 써야 한다.
- 시스템 디자인은 그 자체로 문제를 해결하도록 적절한 행동을 취할 수 있어야 한다.

1. 시스템을 컴포넌트로 나누기

- 장애 허용 시스템을 디자인하는 동안, 첫 번째 필요 조건은 시스템을 부분, 즉 각각 어떤 기능에 대한 책임이 있는 컴포넌트로 나눈다.
- 시스템의 컴포넌트 중 하나에서 특정 장애가 발생하더라도 시스템의 다른 부분에 간섭하기 않아야 하며, 시스템의 연쇄적으로 장애가 발생하지 않아야 한다.

2. 시스템의 중요한 컴포넌트에 집중하기

- 시스템이 가져와야 하는 중요한 부분이 있다.
- 이런 부분은 정확하지 않는 결과를 피하기 위해 고장난 부분으로부터의 간섬이 없이 작동해야 한다.

3. 중요한 컴포넌트의 백업

- 고장이 난 경우 유사한 컴포넌트가 시스템의 고가용성을 보장할 수 있다.

### 컴포넌트란

- 컴포넌트는 독립적이며, 격리되고, 캡슐화된 개체로 다른 영향을 주지 않음을 의미한다.
- 각 컴포넌트가 같은 모듈을 사용할 수는 있지만, 그 컴포넌트만의 행위는 그것이 가진 모듈
- 비동기적인 메시지 전달이 이들 사이의 통신 계층을 구축하는 방법이다.

### 장애 허용 시스템 구축

1. 중복: 중복의 목적은 시스템 컴포넌트의 인스턴스를 여러 개 실행시켜 장애가 발생하면 다른 인스턴스가 요청을 처리하도록 하는 것이다.
2. 복제: 복제의 목적은 컴포넌트의 인스턴스를 여러 개 준비해 이들 모두에게 요청을 직접 송신하는 것이다.
3. 격리: 격리의 목적은 각 프로세스에서 실행되도록 유지, 메시지 전달로 통신해 우려사항을 격리시켜 이들 사이의 결합을 완화 시키는 것

- 어떤 컴포넌트든 다른 컴포넌트의 실패에 영향을 받지 않게 하려는 것

4. 위임: 위임의 목적은 태스크의 처리 책임을 다른 컴포넌트로 넘겨 위임 컴포넌트가 처리하게 하거나, 아니면 실패 처리 또는 경과 보고 등 추가동작이 필요한 경우 위임된 작업의 진행 과정을 선택적으로 관찰하려는 것이다.

### 아카로서 작용

- 아카 슈퍼바이저 액터: 감독하는 액터의 실행을 재개, 중단, 재시작 종료할 수 있다. - 장애 허용을 위한 방법으로 제공
- 부모 - 자식 모델 액터: 앱을 나무와 같은 계층 구조로 구축할 수 있다.
- 고장이 난 경우 중복된 액터를 만들고, 감독 전략을 통해 장애가 발생한 액터를 교체할 수 있다.
- 아카 액터는 컴포넌트로써 생명주기를 가진다.
- 비동기 메시지 전달은 서로 다른 컴포넌트의 우려 사항을 분리할 수 있도록 두 엑터 사이에 경계를 만들게 해준다.

## Strategy

### One For One Strategy

형제를 제외한 고장 난 자식만 재시작, 재개 혹은 상위 액터에 보고 한다.

- 감독 전략을 지정하지 않으면 OneForOneStrategy가 디폴트가 된다.
- 액터가 서로 간에 의존적이지 않으며 각각 하나의 작업을 책임지고, 액터하나가 고장 나더라도 다른 것에 영향을 주지 않는다

### All For One Strategy

슈퍼바이저 아래의 액터에 장애가 발생하면 감독 하에 모든 자식에 전략을 적용한다는 의미

- 즉 연결 Actor들이 있다면 연결된 Actor는 모두 재 시작을 하게 된다.

## 라우터

- 메시지 라우팅 메커니즘

1. 같은 형태의 액터들 중에서 가장 덜 바쁜, 즉 메시지가 가장 적은 액터에 메시지를 송신하고 싶을 때
2. 액터에 미시지를 라운드 로빈 순서로 송신하고 싶을 때, 즉 루프의 모든 액터에 메시지를 하나씩 보냄
3. 그룹 내 모든 액터에 하나의 메시지를 송신하고 싶을 때
4. 액터 사이의 작업을 어떤 메커니즘의 도움을 받아 자동으로 재분배하고 싶을 때

- SmallestMailboxPool(n): 메일 박스를 n개 만들어서 가장 작은 것들로 부터 먼저 들어간다
- RoundRobinPool(n): 같은 타입의 액터로 만들어진 그룹이며 루프내 모든 액터에게 메시지가 하나씩 전달되는 속성을 가진다.
- BroadcastPool (n): 같은 메시지를 모든 액터에게 전달하여 같은 작업을 하도록 명령을 송신
- ScatterGaterFirstCompletedPool (n): 동일한 메시지를 모든 액터에게 송신하고, 작업을 먼저 마친 액터를 기다린 후 송신한다. 2번째 부터의 메시지는 모두 버린다.
- TailChoppingPool (n): 무작위로 고른 라우터에게 메시지를 송신한다. 약간의 지연 후에 두번재 라우터(랜덤) 에게 전송한다. 첫 번째 응답을 수신하고 나머지는 버린다.

## Akka Cluster

단일지점의 장애와 단일 지점 병목을 없앤 중앙화 되지 않은 내구성 강한 peer to peer 기반 클러스터 멤버쉽을 제공

- node: 클러스터의 논리 구성원, 물리적 머신에는 여러개의 노드를 사용한다.
- cluster: 멤버십 서비스를 통해 서로 조인 된 노드 세트
- leader: 리더로 작동하는 클러스터의 단일 노드, 클러스터 통합 맴버 상태 전환 관리

### memberShip

- 클러스터는 일련의 구성원 노드로 구성이 된다. 각 노드의 식별자는 hostname: port: uid tuple이다.
- Akka 응용 프로그램은 각 노드가 응용 프로그램의 일부 호스팅을 하는 클러스터를 통해 배포할 수 있다.
- 클러스터 멤버쉽과 애플리케이션의 해당 노드에서 실행중인 액터는 분리
- 노드는 액터를 호스팅 하지 않고 클러서터의 구성원이 될 수 있다.

### 장점

- 내결함성: 클러스터는 장애에서 우아하게 복구된다.
- 탄력적: 클러스터는 본질적으로 탄력적이며 필요에 따라 확장/축소 할 수 있다.
- 분산화: 클러스터 전체에서 동시에 실행되는 특정 마이크로서비스 또는 애플리케이션 상태의 동일한 복제본을 여러 개 가질 수 있다.
- 피어 투 피어: 새 노드는 기존 피어에 연결하고 다른 피어에 대해 알림을 받고 구성 변경 없이 네트워크에 완전히 통합될 수 있다.
- 단일 장애 지점/병목 현상 없음: 여러 노드가 요청을 처리할 수 있어 처리량과 내결함성이 향상

### Cluster vs Remote

- Cluster는 Remote 위에 있는 추상화 계층
- Remote는 Cluster에 전원을 공급하므로 Remote로 할 수 있는 모든 작업은 CLuster에서도 지원

### Gossip

- 노두가 구성 변경 없이 클러스터를 가입하고 탈퇴할 수 있는 방법
- 클러스터의 노드 간 전달되는 메시지의 지속적인 흐름으로, 클러스터의 각 구성원 상태의 클러스터 구성원을 업데이트
- 노드가 클러스터에 참여하려면 먼저 구성된 시드 노드 중 하나에 연결해야 한다.
- 하나의 시드 노드에 연결할 수 있게 되면 클러스트의 구성원에 대한 정보가 포함된 Gossip 메시지를 수신하기 시작한다.

## AKKA Persistence

내부 상태를 유지하기 위한 상태 보전형 액터를 사용하므로서 액터가 시작되거나 JVM 충돌 후 재시작되거나 감독자에 의해 재시작되거나 클러스터에서 마이그레이션 될때 복구할 수 있다.

- Actor의 내부 상태에 대한 변경 사항만 지속되지만 현재 상태는 그대로 유지되지 않는 다는 것
- 변경사항은 오직 storage에만 추가되고 아무 것도 변화되지 않으며 매우 높은 tranaction 속도와 효율적인 복제가 가능하다.
- 상태 보존 형 액터는 내부 상태를 재구성 할 수 있는 액터에 저장된 변경 사항을 재생하여 복구된다.
- 변경 기록 전체 또는 복구 시간을 대폭 단축 할 수 있는 스냅 샷에서 시작한다.

- Akka Persistence는 적어도 한 번 이상 메시지 전달 Sematics을 사용하여 지점 간 통신을 제공한다.
- 즉, 액터가 진행하지 못한 메일박스에 있는 메시지를 영구적으로 저장해놨다가 복원하여 계속 해서 진행할 방법

### Architecture

- AbstractPersistentActor: 어떤 Persistent Actor가 시작하거나, 재시작 되면 기록된 메시지들이 재실행되서 액터의 Internal State를 복구한다.
  - 엑터의 상태를 직접적으로 저장하는 것이 아니라, 액터와 액터가 처리한 메시지를 기록해 놓는다.
  - 액터가 (재)시작되면 이전에 처리한, 기록된 메시지를 그대로 다시 실행시킴으로써 액터의 상태를 복구한다.
- PersistentView: 이 View는 다른 Persistence 액터에 의해 쓰여진 저널링 메시지를 수신하는 영구적인 상태 유지 Actor
  - View는 스스로 메시지를 저널링하지 않고 Persistence Actor에 복제된 메시지 Stream으로부터 오직 내부 상태만 업데이트 한다.
- Snapshot Store: Persistence Actor 또는 View의 내부 상태의 스냅 샷을 유지한다.
  - 스냅 샷은 복구 시간을 최적화 하는데 사용된다.
  - 메시지를 일일이 기록해놨다가 재생하는게 아니라, 상태 자체를 스냅샷으로 기록하고 복구한다.

### Event Sourcing

액터에게 발생한 모든 이벤트를 저장하는게 아니라, Validation과정을 거쳐서 액터의 상태를 성공적으로 변경시킨 이벤트에 한해서만 이벤트를 저장한다.

- Persisient Actor가 이벤트를 재생할 때는 실패가 발생할 수 없다.

메시지를 커멘드와 이벤트로 분리한다

- 커멘드: 액터가 받은 메시지
- 이벤트: 커멘트를 수정하여 이벤트로써 저장할 정보만 뽑아낸다.

이벤트는 ExampleState라는 별도의 메서드를 뽑아낸다.

- CreateReceiveRecover 메서드는 액터의 복구가 진행될 때 Evt, SnapshotOffer 메시지를 처리함으로써 액터의 상태가 어떻게 변하는지 정의한다.
