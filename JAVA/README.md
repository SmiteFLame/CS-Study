# JAVA

객체지향 언어, 이식성 높은 언어, 인터프린터 언어

### JAVA의 특징

1. 자바는 객체 지향 언어이다.
2. JVM위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행 가능
3. 고성능, 바이트 코드로 변환 가능
4. 멀티 스레딩 가능

## 자바 구성 요소

### 자바 컴파일러

- 자바를 가지고 작성한 자바소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이크 코드로 변환한다.
- 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일형태로 설치된다.

### 자바 바이트 코드

- 자바 가상머신이 이해할 수 있는 언어로 변환된 자바 소스코드를 의미한다.
- 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트이다.
- 자바 바이트 코드는 자바 가상머신만 설치 되어 있으면, 어느 OS에서도 사용 가능하다.
-

### JVM

자바 가상머신으로 자바 애플리케이션을 클래스 로더를 통해 읽고 자바 API를 실행<br>
JAVA와 OS 사이의 중개자 역할을 하면서 JAVA는 OS에 구애받지 않고 재사용을 가능하게 해준다.

1. Interpreter

- 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할

2. Class Loader

- 동적으로 클래스를 읽어오므로, 프로그램이 실행중인 런타임에서야 모든 코드 자바 가상 머신과 연결
- 동적으로 클래스를 로딩해주는 역할

3. Just-In-Time Compiler

- 프로그램이 실행 중인 런타임에 실제 기계어로 변환해주는 컴파일러를 의미한다.
- 즉, 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는데 사용한다.
  (기계어 - CPU가 직접 해독하고 실행할 수 있는 비트 단위로 쓰인 컴퓨터 언어, 프로그램을 나타내는 가장 낮은 단게의 개념)

4. Garbarge Collector

- 더 이상 사용하지 않는 메모리를 자동으로 회수해서 제거하는 역할

### JAVA의 메모리 영역

1. Class Area = Method Area = Static Area<br>

- JVM에 가장 먼저 처음 메모리 공간, 클래스와 Static을 올린다(클래스 로딩)

2. Stack Area <br>

- 지역변수와 매개변수가 저장된다. <br>
- 메소드 호출이 끝나면 모든 변수가 스택에서 제거

3. Heap Area <br>

- new 명령을 통해 생성된 인스턴스 변수가 놓인다. <br>
- 더 이상 호출하는 것이 없어질 때까지 존재한다 <br>

- 참조 변수에 저장되는 메모리 주소는 Stack에 저장
- 그 주소가 가르키는 메모리는 모드 Heap에 저장

4. PC Register

- Thread가 생성될 떄 마다 생성되는 Pragram Counter<br>
- 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 잇는 영역

5. Native Method Stack

- 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역

- 스레드 생성시 Method, Heap영역은 모든 스레드가 공유한다.

<br>
메모리 관리, GC을 수행하나는 스택 기반의 가상 머신이다.

클래스 로더 - 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크한다.

<hr>

## JAVA의 종류

### JAVA JDK(Java Development Kit)

JAVA로 된 언어를 컴파일 하고 개발 할 수 있도록 해주는 개발 환경의 세트 <br>
개발자만을 위한 컴파일러, 디버깅 툴들을 제공 <br>
JAVA SE, JAVA EE, JRE, JVM을 통합 <br>

### JAVA SE

- 스탠다드 에디션으로 가장 많이 사용되는 기본 JAVA로써 표준 문법을 의미한다.

### JAVA EE

- SE 기반으로 서버측을 개발하기 위해서 EJB, JSP, Servlet을 지원해준다

### JAVA ME

- 제한된 자원을 휴대폰, 셋텁박스등 임베디드 시스템에서 자바로 프로그램 개발할 때 이용한다.

<hr>

## OOP

### 5원칙

1. 단일 책임 원칙

- 한 클래스는 하나의 책임만 가진다

2. 개방 폐쇠 원칙

- 확장에는 열려 있고 변경에는 닫혀 있어야 한다.

3. 리스코프 치환 원칙

- 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다.

4. 의존 역전의 원칙

- 의존 관계를 맺을 때 구체적인 것보다 추상적인 것에 의존해야 한다
- 클래스보다 추상클래스나 인터페이스에 의존해야 한다.

5. 인터페이스 분리의 법칙

- 한 클래스는 자신이 사용하지 않는 인터페이스를 구현하지 말아야 한다.
- 하나의 일반적인 인터페이스보다, 여러개의 인터페이스가 낫다

### 4특징

1. 캡슐화(Encapsulation)

- 하나의 객체에 대해 그 객체가 특정한 목적을 위한 필요한 변수나 메소드를 하나로 묶는 것
- 실제 구현 부분을 외부에 들어나지 않기 위해 변수와 메서드를 붂는다.
- 데이터를 직접 접근하지 않고 Getter, Setter를 통해서 접근한다.

2. 상속(Inheritance)

- 자식 클래스가 부모 클래스의 특성과 기능을 물려 받는 것
- 기능의 일부분을 변경하는 경우 자식 클래스에서 상속 받아 수정 및 사용함
- 상속은 캡슐화를 유지, 클래스의 재사용이 용이하도록 해준다.

3. 추상화(Abstraciton)

- 인터페이스로 클래스들의 공통적인 특성(변수, 메소드)를 묶어 표현하는 것
- 목적과 관련 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념

4. 다형성(Polymorphism)

- 형태가 같은데 다른 기능을 하는 것을 의미한다
  1. 오버로딩 - 하나의 클래스에서 메소드 이름은 같지만, 파라미터가 다른 것
  2. 오버라이딩 - 부모 클래스의 메소드를 자식 클래스의 용도에 맞게 재정의하는 것

<hr>

### Generices

- 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
- 따로 형 변환이 필요 없고 발생하지 않기 때문에 유용하게 사용 가능

```java
public class Box<T>{
    private T t;
    public T getT(){
        return t;
    }
}

public Util{
    public static <T> Box<T> boxing(T t){
        Box<T> box = new Box<T>();
        box.setT(t);
        return box;
    }
}

// 구체적 타입을 명시하는 호출 방법
Box<Integer> box1 = new Util.<Integer>boxing(100);
// 암묵적 호출 방법
Box<Integer> box2 = new Util.boxing("암묵적호출");
```

<hr>

### Boxing vs Unboxing

1. 기본 타입(Primitive Type) - char, int, float, double....
2. 참조 타입(Reference Type) - class, interface <br>
   Wrapper Class - 기본 타입을 객체로 다루기 위해서 사용하는 것 <br>
   EX) Byte(byte), Integer(int)....

Boxing - 기본타입을 Wrapper Class로 변경
Unboxing - Wrapper Class를 기본 타입으로 변경

<hr>

### 자바 클래스 멤버 변수 초기화 순서

1. Static 변수 선언부 - 클래스가 로드 될 때 변수가 가장 먼저 초기화
2. 필드 변수 선언부 - 객체가 생성될 때 heap 메모리에 올라가고 생성자 block보다 앞서 초기화
3. 생성자 block - 객체가 생성될 때 heap 메모리에 올라간다.
4. 필드 변수 초기화 - JVM에서 내부적으로 로킹

### Serializable

자바 시스템 내부에서 상속되는 Object또는 JVM의 메모리에 상주 되어 있는 Data를 외부 자바 시스템에서도 사용할 수 있도록 Byte형태로 데이터를 변환하는 기술 <br>
이 값들을 주소값을 가지고 있지 않고 실제 값 형식으로 바꿔주면서 데이터 간 정보 통신 가능

<hr>

## 상속

```java
(A는 최상위)
A - a(int i){};
B - b(){};
C - a(){}, b(int i){} - a,b는 오버로딩(파라미터가 다르다)
D - a(int i){}, b() - a,b는 오버라이딩(a는 A, b는 B를 오버라이딩)
E - a(){}, b(){} - a,b는 오버라이딩(a는 C, b는 D를 오버라이딩)

A(호출범위) a = new ? -> a(int i)만 호출 할 수 있다.
B b = -> a(int i)와 b()만 호출 할 수 있다.

A x = new C(); -> 객체는 생성 가능
x.a(); -> 오류 발생(A의 범위에서는 a()를 호출 할 수 없다)

C x = new E();
x.b(3); ->  C에 있는 b(int i)가 실행

D x = new B(); -> 생성에서 오류가 발생
x.b();

B x = new D();
x.a(3);
1. A에서 a(int i)가 있으니 호출이 가능
2. D에서 재정의 되어 있으므로 D(int i)가 호출이 된다.
```

## Garbage Collection

- 프로그램에서 유효하지 않는 메모리를 JVM에서 알아서 정리해주는 것
- 메모리 관리 기법으로 동적으로 할당 했던 영역중에서 필요 없는 부분 해제
- 동적 할당된 메모리 영역 가운데 어떤 변수도 가리키지 않는 메모리 영역 탐지하여 해제

### 장점

1. 프로그래머가 동적으로 할당한 메모리 영역 전체를 관리 안해도 된다.
2. 버그가 감소한다.
   1. 유효하지 않는 포인터 접근 - 이미 동적 할당된 메모리를 해제한 영역에 접근하게 되는 버그
   2. 이중 해제 - 이미 해제된 메모리를 또 다시 해제하는 오류 감소
   3. 메모리 누수 - 더이상 사용하지 않는 메모리를 해제하지 않고 남겨진 것이 쌓으면 메모리 누수 발생 가능

### 단점

1. 어떤 메모리를 해제해야할 지 결정하는데 사용되는 알고리즘에 의해 비용 증가
2. 객체가 필요 없는 시점을 알고 있는 경우에도 GC 알고리즘이 메모리 해제 비용 추적해야됨
3. 실시간 서비스에는 적합하지 않다(GC행동 타이밍, 점유시간 예측 불가능)

<hr>

## 추상클래스 VS 인터페이스

### 추상클래스

1. Default 생성자를 가진다(서브 클래스가 인스턴스화될 때 호출함)
2. 추상 메소드, 비 추상 메소드를 포함 할 수 있다.
3. 상속한 클래스는 모든 메소드를 구현할 필요가 없다.
4. 객체 생성이 불가하므로 extend로 구현

### 인터페이스

1. 생성자를 가지지 않는다.
2. 추상 메소드만 선언할 수 있다.
3. 인터페이스를 구현하는 클래스는 모든 메서드를 구현해야 한다.
4. 객체 생성이 불가하므로 implement로 구현

<hr>

### JDBC

- 자바에서 데이터베이스를 접속할 수 있도록 하는 자바 API
- 데이터 베이스에 자료를 쿼리문을 작성하거나 업데이트 하는 방법을 제공하고 잇다.

### Web Server VS WAS Server

Web - HTML, CSS, JS등 정적인 데이터를 처리하는 웹 서버
WAS - JSP, ASP, PHP등 사용자의 ㅇ비력을 받아 서버에서 처리하는 동적인 서버

사용자 처리 -> WEB 서버 -> WAS 동적 처리 -> WEB 서버 -> 사용자 응답 메시지

<hr>

## 에러 VS 예외

에러 - 시스템에 비정상적인 상황이 생겼을 때 발생

- 시스템 레벨에서 발생하기 때문에 심각한 수준
- 개발자가 미리 예측하여 처리 불가능 하기 때문에 오류에 대한 처리를 신경 안써도 된다.

예외 - 개발자가 구현한 로직에서 발생

- 발생할 상황을 미리 예측하여 처리할 수 잇다.
- 개발자가 처리할 수 있는 곳에 구분하고 처리 방법을 명확히 알고 적용 해야 한다.

<hr>

## Collection

### List vs Set vs Map

List - 순서가 있는 데이터의 집합으로 데이터의 중복을 허용 <br>
Set - 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않음<br>
Map - 키와 값의 상으로 이루어진 데이터의 집합, 키는 중복X, 값은 중복O<br>

### ArrayList vs LinkedList

ArrayList - 배열이 동적으로 늘어나는 것이 아니라 꽉 차게 되면 더 큰 용량의 배열을 만들어서 옮기는 작업을 한다.

- 초기 용량을 설정하는 것이 좋다.
- 읽는 시간이 빠르지만, 추가 삭제가 느리다. (단 순차적인 추가 삭제는 더 빠르다)
- 중간 삽입, 삭제는 O(N) 이지만 get()은 O(1)이다.
  <br>

LinkedList - 내부적으로 양뱡향의 연결 리스크 구성되어 있어서 참조하려는 원소에 따라 처음부터 순향향, 역뱡뱡향 순회 가능

- 크기를 변경할 수 없다
- 비 순차적인 데이터 추가 삭제가 시간이 오래 걸린다.
- 읽는 시간은 느리지만, 추가 삭제가 빠르다.
- get()은 O(N)이지만 중간 삽입 삭제는 O(1)이다.

### HashMap Null 가능?

- Value에서는 가능하다, Treemap은 정렬 순서때문에 불가능하다

### HashMap vs TreeMap vs LinkedHashMap vs HashTable

HashMap - Array의 Index를 hash함수를 통해서 계산한다<br>

- Hash값을 사용하기 때문에 순서를 보장하지 않는다.
- 해당 Array에 바로 접근하기 때문에 get()은 O(1)이다.

TreeMap - Entry가 Tree구조로 저장되어 있다.

- Tree구조로 되어 잇어 정렬이 되어 있다
- Tree 구조때문에 get()은 O(logN) 성능을 보인다.

LinkedHashMap - HashMap과 동일하지만 Entry내에 before, after가 저장되어 있다.

- 입력 메서드의 순서를 보장 받을 수 있다.

HashTable - Map 인터페이스를 구현한 클래스로 중복허용X, 동기화 처리가 되어 있다.

- HashMap과 다르게 Key값으로 null을 허용하지 않는다.

<hr>

## Call By Value vs Call By Reference

### Call By Value

- 함수 안에서 인자 값이 변경되어도 외부의 변수 값은 변경되지 않는다.

### Call By Reference

- 함수 안에서 인자의 값을 변경되면, Argument로 전달된 객체의 값도 변경된다.
