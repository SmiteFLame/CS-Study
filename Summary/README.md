# Backend 개발자가 되기 위한 CS 지식 요약

## 자바

### 자바의 특징

1. 자바는 객체 지향 프로그래밍이 가능한 언어이다
2. JVM위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행한다
3. 고성능, 바이트 코드로 변환이 가능하다, 멀티 스레딩이 가능하다
4. 자동 메모리 관리(GC)가 가능하다

### 자바 컴파일러

자바를 가지고 작성한 코드는 자바 가상 머신이 이해할 수 있도록 바뀐다

### 자바 바이트 코드

자바 가상머신이 이해할 수 있는 언어로 변환된 자바 코드

### JVM

자바 가상머신으로 자바 애플리케이션을 클래스 로더를 통해서 읽는다

1. Interpreter - 자바 컴파일러에 의해 자바 바이트 코드를 읽는 역할
2. Class Loader - 동적으로 클래스를 로딩해주는 역할
3. Just-In-Time Compiler - 자바 컴파일러가 생성한 바이트 코드를 런타임에 바로 기계어로 변역
4. Garbarge Collector - 더 이상 사용하지 않는 메모리를 자동으로 회수

### JAVA의 메모리 영역

1. Class Area - JVM에 가장 먼저 올리는 공간, CLass와 Static(클래스 로딩)
2. Stack Area - 지역변수와 매개변수가 저장, 매서드 호출이 끝나면 모든 변수가 스택에서 제거
3. Heap Area - new 명령을 통해 생성된 인스턴스 변수
4. PC Register - Thread가 생성될 때 마다 생성
5. Native Method Stack- 자바외 언어로 작성된 네이티브 코드를 위한ㅇ 메모리

- 참조 변수에 저장되는 메모리 - Stack
- 그 주소를 가르키는 메모리 - Heap

메모리 관리 - GC을 수행하는 스택 기반의 가상머신
클래스 로더 - 클래스를 처음 참조할 때 해당 클래스를 로드하고 링크

## 객체지향

### OOP의 5원칙

1. 단일 책임 원칙 - 하나의 클래스는 하나의 책임만 갖는다
2. 개방 폐쇠 원칙 - 확장에는 열려 있고 변경에는 닫혀 있어야 한다
3. 리스코프 치환 원칙 - 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다
4. 의존 역전의 원칙 - 의존 관계를 맺을 때 구체적인 것(클래스)보다 추상적인 것(추상클래스, 인터페이스)에 의존해야 한다
5. 인터페이스 분리의 법칙 - 하나의 일반적인 인터페이스보다, 여러개의 인터페이스가 낫다

### 4가지의 특징

1. 캡슐화 - 하나의 객체에 대해 그 객체가 특정한 목적을 위한 변수나 메서드를 하나로 묶는 것
2. 상속 - 자식 클래스가 부모 클래스의 특성과 기능을 물려 받는 것
3. 추상화 - 인터페이스로 클래스들의 공통적인 특성을 묶어 표현하는 것
4. 다형성 - 형태가 같은데 다른 기능을 하는 것

## 데이터베이스

### 데이터무결성

데이터베이스에서 데이터들이 정확성, 일관성, 유효성을 유지하는 것

### 트랜잭션

하나 이상의 쿼리가 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 돌릴 수 있다.

### 트랜잭션의 ACID

- 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다
- 일관성: 트랜잭션에 수행하기 전이나 후에 데이터베이스는 항상 일관됭 상태여야 한다.
- 고립성: 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성: 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

### DB락

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근할 때 이를 제어해 준다
  - 공유 락: 데이터를 읽을 수 있지만 쓸 수 없다
  - 배타 락: 데이터를 읽고 쓸 수 있음

### 인덱스

추가적인 쓰기 작업과 저장 공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

- 장점: 조회 속도 및 성능 향상, 시스템 부하 감소
- 단점: 관리하기 위한 10% 저장 공간 필요, 추가작업 필요, 잘못 하면 오히려 성능 저하

- 해시테이블: 컬럼의 값으로 생성된 기반의 인덱스 구현, 검색 속도 O(1), 순차 검색 X
- B+ Tree: LinkedList로 연결하여 순차 검색이 가능, 해시 테이블보다 속도가 낮음

### 뷰

실제 데이터가 없는 테이블, 사용자의 편의와 보안 떄문에 사용

### 정규화

- 1: 각 컬럼들의 값이 원자값을 가진다
- 2: 테이블의 모든 컬럼에서 부분 함수적 종속을 제거
- 3: 기본키를 제외한 속성들간 이행적 함수 종속을 제거
- BCNF: 결정자이면서 후보키가 아닌 것들 제거

### 관계형 데이터베이스 VS NoSQL

- RDBMS: 2차원의 행과 열로 데이터 관계
  - 스키마에 맞춰서 관리 -> 정합성 보장
  - 시스템이 커질 수록 쿼리가 복잡, 성능 저하
- NoSQL: 비정형 데이터 일때 사용
  - 스키마가 없이 Key-Value로 더 자유롭게 관리 가능
  - 중복된 데이터가 추가 가능하며, 이에 대한 괸리가 편히

### 데이터베이스 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - commit한 데이터만 수정 허용
3. Repeatable Read - 다른 트랜잭션 사용 중 수정, 삭제 불가
4. Serializable - 다른 트랜잭션 사용 중 삭제, 수정, 삭제 불가

### 문제점

1. Dirty Read - 트랜잭션 작업이 완료 되지 않아도 트랜잭션에서 볼 수 있는 현상
2. Non-RepeatedRaed - 트랜잭션의 조회가 처음과 마지막이 다를 수 있다.
3. Phantom Read - 테이블이 같은 쿼리를 두 번 수행시 없는 레코드가 두번째 나오는 경우

### Delete VS Trucate VS Drop

- Delete: 데이터만 삭제, 전체 혹은 일부만 삭제, 롤백 가능, 삭제 행수 반환
- Trucate: 데이터와 인덱스 전체 삭제, 롤백 불가능, 삭제 행수 미 반환
- Drop: 테이블의 구조 자체를 삭제, 롤백 불가능

### 트랜잭션

하나의 논리적인 기능을 수행하기 위한 작업의 단위, 데이터베이스의 일관 상태를 변환 시키는 기능을 수행

- A(원자성): 트랜잭션에서 수행된 내용은 전부 수행이 되거나 전부 수행이 되면 안된다
- C(일관성): 트랜잭션을 수향하기 전이나 후에는 데이터베이스가 항상 일관된 상태여야 한다, 무결성 제약이
- I(고립성): 트랜잭션이 수행디는 동안 다른 트랜잭션이 끼어들어서 값을 훼손하면 안된다
- D(지속성): 수행을 성공적으로 완료한 트랜잭션은 변경한 트랜잭션을 영구히 저장해야 한다

## 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리하고 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공해주는 프로그램들의 모임
- 컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다

### 프로그램 VS 프로세스 VS 스레드

프로그램

- 파일 시스템에 존재하는 실행 파일
- 동작되고 있지 않은 정적인 객체

프로세스

- 실행중인 프로그램으로 주소공간, 파일, 메모리등을 할당받아서 이것들을 총칭한다.
- 프로그램을 실행시켜주는 주체
- 동작하고 있는 동적인 객체

스레드

- 프로세스의 실행 단위로, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
- 프로세스가 할당받은 자원을 이용하는 실행 단위

### Context Switching

현재 진행하고 있는 Task의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정

- 하나의 Task가 끝날때 까지 다음 Task를 기다릴 수 없으므로 바꿔서 실행을 한다
- 순서
  - Task의 정보는 Register에서 저장되고 PCB에서 관리한다
  - 현재 실행하고 있는 Task의 PCB 정보를 저장한다(Process, Stack, Ready Queue)
  - 다음 실행할 PCB 정보를 읽어 Register에 적재하고 CPU 이전에 진행했던 과정을 연속으로 수행할 수 있다.
- Process가 Thread보다 수행 시간이 길다
  - Thread는 Stack 영역만 변경하면 된다

### Interrupt

프로그램을 실행하는 도중에 예기치 않은 상황이 발생하여 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행 중인 작업을 복귀

- 인터럽트 요청이 오면 Context Switching이 일어난다

### 멀티 프로그래밍 VS 멀티 프로세싱

멀티 프로그래밍

- 하나의 프로세서가 하나 이상의 프로그램을 동시에 수행시킨다.
- 여러 개의 프로그램을 메모리에 저장시켜놓고 프로세서를 빠르게 스위치하여 프로그램을 동작 시킨다.

멀티 프로세싱

- 여러개의 프로세스들을 가지고 하나 이상의 프로그램을 수행할 때 사용한다.
- 여러개의 프로세스가 협력하여 효율적이고 빠르세 프로그램을 진행할 수 있다.

### 멀티 프로세스 VS 멀티 스레드

멀티 프로세스

- 하나의 프로세스가 죽더라도 다른 프로세스에 영향이 없다
- 멀티 스레드보다 많은 메모리 공간과 CPU를 차지한다.

멀티 스레드

- 적은 메모리 공간을 차지하여 Context Switch가 빠르다
- 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료되는 동기화 문제가 있다

### 동시성 VS 병렬처리

동시성

- 단일 CPU 코어에서 두 개의 Task가 동시에 진행되는 것 처럼 보인다.

병렬 처리

- 둘 이상의 CPU 코어에서 두 개의 task가 동시에 진행된다.

### 스케쥴러

- 장기(Job): 저장되어 있는 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지
- 단기(CPU): Ready Queue에서 어떤 프로세스를 Running 할지
- 중기(Swapper): 여유 공간을 위해서 어떤 프로세스를 메모리에서 디스크로 보낼지

## 동기 VS 비동기

- 동기: 메소드 실행함으로써 반환값을 기대한다.
  - 반환 되기 전까지는 blocking 된다.
- 비동기: 메소드를 실행함으로써 반환값을 기대하지 않는다.

### Critical Section

멀티 Task 환경에서 하나의 Task가 자신의 Critical Section에서 수행을 하고 있으면 다른 Task는 그 Critical Section에 접근 할 수 없다

Critical Section의 3가지 조건

1. Mutual Exclusion(상호 배제) - Critical Section에 실행되고 있으면 다른 Task는 들어갈 수 없다.
2. Process(진행)- Critical Section에 진행되고 있는 Task가 없으면 Task가 들어갈 수 있다.
3. Bounded Waiting(한정된 대기) Critical Section 진입 횟수에 한계가 있어 계속 독점에서 사용할 수 없다.

해결 방법

1. Lock - Critical Section에 접근하면 Lock을 획득하고 Critical에 나오면 Lock을 방출 한다.

- 서로 연관된 프로세스들이 엉켜서 DeadLock이 생길 수 있다.

2. Mutex(Binary Semaphore) - Lock과 유사하지만, 무한 루프를 돌지 않고 기다리며 Context Switching을 실행한다.
3. Count Semaphore - 정수값을 가지는 변수로 볼 수 있으며, 최대 접근 가능한 허용치를 준다.

- 현재 수행중이 아닌 다른 프로세스가 Semaphore를 해제할 수 있다.
