# Backend 개발자가 되기 위한 CS 지식 요약

## 자바

### 자바의 특징

1. 자바는 객체 지향 프로그래밍이 가능한 언어이다
2. JVM위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행한다
3. 고성능, 바이트 코드로 변환이 가능하다, 멀티 스레딩이 가능하다
4. 자동 메모리 관리(GC)가 가능하다

### 자바 컴파일러

자바를 가지고 작성한 코드는 자바 가상 머신이 이해할 수 있도록 바뀐다

### 자바 바이트 코드

자바 가상머신이 이해할 수 있는 언어로 변환된 자바 코드

### JVM

자바 가상머신으로 자바 애플리케이션을 클래스 로더를 통해서 읽는다

1. Interpreter - 자바 컴파일러에 의해 자바 바이트 코드를 읽는 역할
2. Class Loader - 동적으로 클래스를 로딩해주는 역할
3. Just-In-Time Compiler - 자바 컴파일러가 생성한 바이트 코드를 런타임에 바로 기계어로 변역
4. Garbarge Collector - 더 이상 사용하지 않는 메모리를 자동으로 회수

### JAVA의 메모리 영역

1. Class Area - JVM에 가장 먼저 올리는 공간, CLass와 Static(클래스 로딩)
2. Stack Area - 지역변수와 매개변수가 저장, 매서드 호출이 끝나면 모든 변수가 스택에서 제거
3. Heap Area - new 명령을 통해 생성된 인스턴스 변수
4. PC Register - Thread가 생성될 때 마다 생성
5. Native Method Stack- 자바외 언어로 작성된 네이티브 코드를 위한ㅇ 메모리

- 참조 변수에 저장되는 메모리 - Stack
- 그 주소를 가르키는 메모리 - Heap

메모리 관리 - GC을 수행하는 스택 기반의 가상머신
클래스 로더 - 클래스를 처음 참조할 때 해당 클래스를 로드하고 링크

## 객체지향

### OOP의 5원칙

1. 단일 책임 원칙 - 하나의 클래스는 하나의 책임만 갖는다
2. 개방 폐쇠 원칙 - 확장에는 열려 있고 변경에는 닫혀 있어야 한다
3. 리스코프 치환 원칙 - 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다
4. 의존 역전의 원칙 - 의존 관계를 맺을 때 구체적인 것(클래스)보다 추상적인 것(추상클래스, 인터페이스)에 의존해야 한다
5. 인터페이스 분리의 법칙 - 하나의 일반적인 인터페이스보다, 여러개의 인터페이스가 낫다

### 4가지의 특징

1. 캡슐화 - 하나의 객체에 대해 그 객체가 특정한 목적을 위한 변수나 메서드를 하나로 묶는 것
2. 상속 - 자식 클래스가 부모 클래스의 특성과 기능을 물려 받는 것
3. 추상화 - 인터페이스로 클래스들의 공통적인 특성을 묶어 표현하는 것
4. 다형성 - 형태가 같은데 다른 기능을 하는 것

## 데이터베이스

### 데이터무결성

데이터베이스에서 데이터들이 정확성, 일관성, 유효성을 유지하는 것

### 트랜잭션

하나 이상의 쿼리가 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 돌릴 수 있다.

### 트랜잭션의 ACID

- 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다
- 일관성: 트랜잭션에 수행하기 전이나 후에 데이터베이스는 항상 일관됭 상태여야 한다.
- 고립성: 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성: 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

### DB락

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근할 때 이를 제어해 준다
  - 공유 락: 데이터를 읽을 수 있지만 쓸 수 없다
  - 배타 락: 데이터를 읽고 쓸 수 있음

### 인덱스

추가적인 쓰기 작업과 저장 공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

- 장점: 조회 속도 및 성능 향상, 시스템 부하 감소
- 단점: 관리하기 위한 10% 저장 공간 필요, 추가작업 필요, 잘못 하면 오히려 성능 저하

- 해시테이블: 컬럼의 값으로 생성된 기반의 인덱스 구현, 검색 속도 O(1), 순차 검색 X
- B+ Tree: LinkedList로 연결하여 순차 검색이 가능, 해시 테이블보다 속도가 낮음

### 뷰

실제 데이터가 없는 테이블, 사용자의 편의와 보안 떄문에 사용

### 정규화

- 1: 각 컬럼들의 값이 원자값을 가진다
- 2: 테이블의 모든 컬럼에서 부분 함수적 종속을 제거
- 3: 기본키를 제외한 속성들간 이행적 함수 종속을 제거
- BCNF: 결정자이면서 후보키가 아닌 것들 제거

### 관계형 데이터베이스 VS NoSQL

- RDBMS: 2차원의 행과 열로 데이터 관계
  - 스키마에 맞춰서 관리 -> 정합성 보장
  - 시스템이 커질 수록 쿼리가 복잡, 성능 저하
- NoSQL: 비정형 데이터 일때 사용
  - 스키마가 없이 Key-Value로 더 자유롭게 관리 가능
  - 중복된 데이터가 추가 가능하며, 이에 대한 괸리가 편히

### 데이터베이스 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - commit한 데이터만 수정 허용
3. Repeatable Read - 다른 트랜잭션 사용 중 수정, 삭제 불가
4. Serializable - 다른 트랜잭션 사용 중 삭제, 수정, 삭제 불가

### 문제점

1. Dirty Read - 트랜잭션 작업이 완료 되지 않아도 트랜잭션에서 볼 수 있는 현상
2. Non-RepeatedRaed - 트랜잭션의 조회가 처음과 마지막이 다를 수 있다.
3. Phantom Read - 테이블이 같은 쿼리를 두 번 수행시 없는 레코드가 두번째 나오는 경우

### Delete VS Trucate VS Drop

- Delete: 데이터만 삭제, 전체 혹은 일부만 삭제, 롤백 가능, 삭제 행수 반환
- Trucate: 데이터와 인덱스 전체 삭제, 롤백 불가능, 삭제 행수 미 반환
- Drop: 테이블의 구조 자체를 삭제, 롤백 불가능

### 트랜잭션

하나의 논리적인 기능을 수행하기 위한 작업의 단위, 데이터베이스의 일관 상태를 변환 시키는 기능을 수행

- A(원자성): 트랜잭션에서 수행된 내용은 전부 수행이 되거나 전부 수행이 되면 안된다
- C(일관성): 트랜잭션을 수향하기 전이나 후에는 데이터베이스가 항상 일관된 상태여야 한다, 무결성 제약이
- I(고립성): 트랜잭션이 수행디는 동안 다른 트랜잭션이 끼어들어서 값을 훼손하면 안된다
- D(지속성): 수행을 성공적으로 완료한 트랜잭션은 변경한 트랜잭션을 영구히 저장해야 한다

## 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리하고 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공해주는 프로그램들의 모임
- 컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다

### 프로그램 VS 프로세스 VS 스레드

프로그램

- 파일 시스템에 존재하는 실행 파일
- 동작되고 있지 않은 정적인 객체

프로세스

- 실행중인 프로그램으로 주소공간, 파일, 메모리등을 할당받아서 이것들을 총칭한다.
- 프로그램을 실행시켜주는 주체
- 동작하고 있는 동적인 객체

스레드

- 프로세스의 실행 단위로, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
- 프로세스가 할당받은 자원을 이용하는 실행 단위

### Context Switching

현재 진행하고 있는 Task의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정

- 하나의 Task가 끝날때 까지 다음 Task를 기다릴 수 없으므로 바꿔서 실행을 한다
- 순서
  - Task의 정보는 Register에서 저장되고 PCB에서 관리한다
  - 현재 실행하고 있는 Task의 PCB 정보를 저장한다(Process, Stack, Ready Queue)
  - 다음 실행할 PCB 정보를 읽어 Register에 적재하고 CPU 이전에 진행했던 과정을 연속으로 수행할 수 있다.
- Process가 Thread보다 수행 시간이 길다
  - Thread는 Stack 영역만 변경하면 된다

### Interrupt

프로그램을 실행하는 도중에 예기치 않은 상황이 발생하여 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행 중인 작업을 복귀

- 인터럽트 요청이 오면 Context Switching이 일어난다

### 멀티 프로그래밍 VS 멀티 프로세싱

멀티 프로그래밍

- 하나의 프로세서가 하나 이상의 프로그램을 동시에 수행시킨다.
- 여러 개의 프로그램을 메모리에 저장시켜놓고 프로세서를 빠르게 스위치하여 프로그램을 동작 시킨다.

멀티 프로세싱

- 여러개의 프로세스들을 가지고 하나 이상의 프로그램을 수행할 때 사용한다.
- 여러개의 프로세스가 협력하여 효율적이고 빠르세 프로그램을 진행할 수 있다.

### 멀티 프로세스 VS 멀티 스레드

멀티 프로세스

- 하나의 프로세스가 죽더라도 다른 프로세스에 영향이 없다
- 멀티 스레드보다 많은 메모리 공간과 CPU를 차지한다.

멀티 스레드

- 적은 메모리 공간을 차지하여 Context Switch가 빠르다
- 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료되는 동기화 문제가 있다

### 동시성 VS 병렬처리

동시성

- 단일 CPU 코어에서 두 개의 Task가 동시에 진행되는 것 처럼 보인다.

병렬 처리

- 둘 이상의 CPU 코어에서 두 개의 task가 동시에 진행된다.

### 스케쥴러

- 장기(Job): 저장되어 있는 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지
- 단기(CPU): Ready Queue에서 어떤 프로세스를 Running 할지
- 중기(Swapper): 여유 공간을 위해서 어떤 프로세스를 메모리에서 디스크로 보낼지

## 동기 VS 비동기

- 동기: 메소드 실행함으로써 반환값을 기대한다.
  - 반환 되기 전까지는 blocking 된다.
- 비동기: 메소드를 실행함으로써 반환값을 기대하지 않는다.

### Critical Section

멀티 Task 환경에서 하나의 Task가 자신의 Critical Section에서 수행을 하고 있으면 다른 Task는 그 Critical Section에 접근 할 수 없다

Critical Section의 3가지 조건

1. Mutual Exclusion(상호 배제) - Critical Section에 실행되고 있으면 다른 Task는 들어갈 수 없다.
2. Process(진행)- Critical Section에 진행되고 있는 Task가 없으면 Task가 들어갈 수 있다.
3. Bounded Waiting(한정된 대기) Critical Section 진입 횟수에 한계가 있어 계속 독점에서 사용할 수 없다.

해결 방법

1. Lock - Critical Section에 접근하면 Lock을 획득하고 Critical에 나오면 Lock을 방출 한다.

- 서로 연관된 프로세스들이 엉켜서 DeadLock이 생길 수 있다.

2. Mutex(Binary Semaphore) - Lock과 유사하지만, 무한 루프를 돌지 않고 기다리며 Context Switching을 실행한다.

- 오직 1개의 Task만 접근 할 수 있다

3. Count Semaphore - 정수값을 가지는 변수로 볼 수 있으며, 최대 접근 가능한 허용치를 준다.

- 세마포어의 변수만큼 Task에 접근 할 수 있다.

- 현재 수행중이 아닌 다른 프로세스가 Semaphore를 해제할 수 있다.

### DeadLock

둘 이상의 프로세스가 Critical Section 집입을 무한정 기다리고 Critical Section에 실행되는 프로세스는 진입 대기중인 프로세스가 실행되어야만 빠져 나올 수 있는 상태

교착 상태 조건

1. 상호 배제(Mutual Exclusion): 한 리소스는 한 번에 한 프로세스만을 사용할 수 있다.
2. 점유 대기(Hold and Wait): 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면 다른 프로세스가 가지고 있는 리소스를 기다리고 있음
3. 비선점(No Preemption): 프로세스가 Task를 마친 후 리소스를 자발적으로 반환 할대 까지 기다림
4. 환형 대기(Circular Wait): Hold and Wait 관계의 프로세스들이 서로 기다림

교창 상태 방지법

1. 방지(Prevention): 교착 상태가 발생할 수 있는 요구 조건을 만족시키지 않도록 한다.
2. 회피(Avoidance): 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않는다.

- 은행원 알고리즘, 자원 할당 알고리즘

3. 탐지 및 회복(Detection and Recovery): 교착 상태가 발생 할 수 있도록 놔 두고 교착 상태가 발생할 경우 찾아내어 고친다.

### 메모리 영역

1. 코드 영역: 실행할 프로그램의 코드가 저장되는 영역
2. 데이터 영역: Global, Static 변수가 저장되는 영역

- 프로그램 시작과 동시에 할당, 프로그램이 종료되면 소멸

3. 힙 역역: 프로그래머가 직접 관리할 수 있는 메모리 영역, 동적 할당되는 영역

- 코드 중에 변수가 선언이 되면 힙 영역에 할당된다.
- 메모리 크기 제한이 없고, 변수를 전역적으로 엑세스 할 수 있다.

4. 스택 영역: 함수의 호출과 함계 할당되며 지역 변수, 매개 변수가 저장되는 영역

- 함수의 호출이 완료되면 소멸한다.
- 4개의 메모리 중에서 가장 높은 주소에 할당이 된다.
- 매우 빠른 엑세스, 지역 변수만 되지만 크기 조정이 불가능하다.
- 공간은 CPU에서 관리하여 매우 효율적이다.

### 단편화

프로세스들 메모리 적재되고 제거 되면서 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 자유 공간들이 늘어나게 되는 형상

- 외부 단편화: 물리 메모리 사이 공간들을 합치면 충분하지만 분산되어 있는 경우
- 내부 단편화: 프로세스 사용하는 메모리 공간에 포함된 남는 부분

- 페이징: 외부 단편화 해결
  - 물리 메모리는 Frame이라는 고정 크기로 분리되고, 논리 메모리는 Page로 고정 크기 분리
- 세그멘테이션: 내부 단편화 해결
  - 서로 다른 크기의 논리적 단위인 Segment를 사용하여 두 개의 주소를 지정
- 페이징은 가상 메모리에서도 물리 메모리와 마찬가지로 고정된 크기의 프레임 단위를 나눠서 관리
- 세그멘테이션은 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위로 분할

### 가상 메모리

프로세스 전체를 메모리에 올리지 않아도 실행할 수 있도록 하는 기법

- 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다.
- 작은 메모리를 가지고도 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.

페이지

- 가장 메모리를 일정한 크기로 나눈 블록

페이지 폴트

- 프로그램이 자신의 주소 공간에는 존재하지만 시스템의 RAM에는 없는 데이터나 코드에 접근을 시도한 경우 발생
- 페이지 폴트가 발생하면 OS는 그 데이터를 메모리에 가져와서 마치 페이지 폴트가 전혀 발생하지 않는 거서럼 프로그램이 계속 동작하게 해준다.

### 시스템 콜

운영체제의 서비스에 접근하기 위한 인터페이스

- 권한이 낮은 응용 SW 커널에 제공하는 서비스를 사용하는 방법

커널

- 부팅되는 동안 메모리르 로드하는 OS의 첫 부분
- 지속적으로 읽어들일 수 있도록 되어 있으며, 메모리 상에서 사용자가 접근할 수 없도록 커널 영역에서 보호된다.

## Spring

JAVA의 웹 프레임 워크로 JAVA 기술들을 더 쉽게 사용할 수 있게 해주는 오픈 소스 프레임 워크

- 프레임 워크: 자주 쓰이는 기능들을 모아 놓은 유틸들의 모음

- IOC: 객체 생명주기 관리를 개발자가 하는게 아닌 스프링(컨테이너) 대신 해주는 것
  - New 연산자, 인터페이스 호출, 데이터 클래스 호출을 대신 관리
- DI: 구성요소 간의 의존 관계가 소수 내부가 아닌 외부 파일을 통해 정의
  - XML을 통한 주입, 생성자를 통한 주입, 속성을 통한 주입, Autowired를 통한 주입
- AOP: 여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법
- POJO: Getter, Setter를 가진 단순한 자바 오브젝트

IOC - 객체의 흐름, 생명주기 관리를 독립적인 제 3자에게 역할과 책임을 위임하는 방식

DI - 인터페이스를 통해 다이나믹 하게 객체를 주입하여 유연한 프로그래밍을 가능하게 한다.

### Spring Boot

단독으로 실행되는 상용화 가능한 수준의 스프링 기반 애플리케이션을 쉽게 만든다.

- WAS에 대한 설정 없이 바로 개발에 들어갈 수 있도록 만든 프레임 워크
- 스프링 프레임워크를 사용하려면 많은 XML 설정 파일들을 장성해야하고, 기존에 사용했던 설정들을 copy and paste하거나 검색을 통해 일일이 설정을 해야하나 스프링 부트를 사용하면 복잡한 설정 없이 쉽고 빠르게 프레임워크를 사용할 수 있다.

### Spring MVC

Model-View-Controller으로 구성이 되어 있는 있다.

- Web Server에 특화되어 만들어진 모듈로, 개발자가 해야할 영역을 더 적게 만들어 준다.
- Model: '데이터'의 디자인을 담당, 최대한 구체적이고 작은 Entity를 유지
- View: 실제 랜더링 되어 보이는 페이지, HTML, 도메인 모델의 상태를 변환하거나 받아서 렌더링
- Controller: Model과 View를 연결해주면서 동작 순서나 방식을 제어한다.

- 장점: 도메인을 작은 역할 단위로 분리하여 설계하는 작업으로 분리되어 각자의 역할에 집중할 수 있다.
- 단점: Model과 View의 완벽한 분리가 힘들다

### Spring 동작 순서

1. Client는 URL을 통해 Request한다.
2. DispatcherServlet는 HandlerMapping을 통해 Request가 어느 Controller에게 온 요청인지 찾는다.
3. DispatcherServlet는 HandlerAdapter를 통해 Request를 전달을 맡긴다.
4. HandlerAdapter는 해당 Controller에게 Request를 전달한다.
5. Controller는 로직을 처리한후 반환할 View의 이름을 반환한다.
6. DispatcherServlet는 ViewResolover를 통해 반환할 View를 찾는다.
7. DispatcherServlet는 Controller에서 View에 전달할 데이터를 추가한다.
8. 데이터가 추가된 View를 반환한다.

### Annotation

- Component: Spring에서 관리하는 객체임을 표시하는 기본적인 Annotation
- Service: 서비스 레이어로 주로 내부의 자바 로직을 처리한다.
- Repository: DB나 파일 같은 외부 I/O 작업을 처리한다
- Controller: View에 주로 반환하기 위해서 사용한다.
  - 데이터를 반환하는 경우 ResponseBody를 사용한다.
- RestController: Controller에 ResponseBody를 추가하여 JSON 형태의 객체를 반환하기 위해 사용한다.

## Infra

### 3계층형 아키텍처

1. 프레젠테이션 계층: 사용자의 입력을 받고 브라우저에 표시

- 주로 웹 서버를 의미한다.

2. 애플리케이션 계층: 사용자의 요청에 따라 업무를 처리한다.

- 주로 앱 서버를 의미한다.

3. 데이터 계층: 애플리케이션 계층의 요청에 따라 입출력한다.

- 주로 데이터베이스 서버를 의미한다.

장점

- 서버 주하 집중이 개선된다.
- 클라이언트 단말의 정기 업데이트가 불필요하다
- '처리 반환'에 의한 서버 부하가 절감된다.
- 웹 디자이너, 소프트웨어 엔지니어, DB 관리자가 역할 분담을 하여 일을 효율적으로 할 수 있다.

분리하는 이유

1. 데이터베이스를 보호한다.

- 데이터베이스는 변경이 적지만 망가지면 매우 위험하므로 보호를 해야 한다.
- 동적 데이터들은 데이터베이스로부터 생성이 된다.
- 대량의 트래픽이 들어오면 데이터베이스는 버티지 못한다.
- 트래픽이 많지 않다면 크게 분리할 이유 없고 오히려 필요 없는 코드가 될 수 있다.

2. 정적인 컨텐츠와 동적인 컨텐츠를 분리한다.

- 정적인 데이터들을 바르게 돌려주기 위함이다.
- 동적인 데이터들은 AJAX, Jquery를 위한 것은 빠르게 데이터를 가져온다.
- Web Server를 Static하게 사용하고 비동기로 요청할 수 있다.

### 서버

클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 시스템으로 컴퓨터 프로그램, 장치를 의미한다.

구성

- PC와 물리적으로 기본적 구성이 같다.
- CPU, 메모리 저장장치등을 가지고 있고 클라이언트의 요청에 대응하기 위해 고성능을 갖추고 있다.
- CPU: 서버 중심에 연산 처리를 실시한다. 명령과 데이터는 기억 장치나 입출력 장치를 통해 전달된다.
- 메모리: 기억 명령을 수행한다. CPU 옆에서 전달하는 내용이나 데이터를 저장하거나 처리 결과를 받는다.

- HDD: 메모리에 비해 CPU에서 멀리 떨어진 곳에 HDD가 배치된다.
  - 장기 저장 목적의 데이터 저장 장소로 사용된다.
  - 전기가 없을 경우 메모리는 사라지지만, 디스크는 유지된다.

### 쿠키

클라이언트 로컬에 저장되는 Key-Value 쌍의 작은 데이터 파일

1. 클라이언트가 서버에 로그인 요청
2. 서버는 클라이언트 요청의 유효성을 확인하고 응답 헤더에 set-cookie에 추가하여 응답
3. 클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청 헤더에 추가하여 요청

### 세션

브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술

1. 클라이언트가 서버에 로그인 요청
2. 서버가 클라이언트 요청의 유효성을 확인하고 unique한 id를 sessionid 이름으로 저장
3. 서버가 응답할 때 응답 해더에 set-cookie: sessionid:"쿠키아이디"를 추가
4. 클라이언트는 이후 서버에 요청할 때 마다 전달받은 sessionId 쿠기를 자동으로 요청 헤더에 추가
5. 서버는 요청 헤더에 sessionid값을 저장된 세션 저장소를 찾아보고 유효한지 확인 후 요청을 처리하고 응답

### Web Server

HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스 하는 기능

- WAS: DB 조회나 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
  - WAS = Web Server + Web Container
  - Web Container: Servlet, JSP를 실행할 수 있는 소프트웨어
    - Web Server에서 JSP요청하면 Web Container에서는 JSP 파일을 Servlet 파일로 변환 한 뒤 컴파일 하여 실행 결과를 Web Server에 전달

### App Server

실제 구현 비즈니스 로직을 위한 서버

- httpd: HTTP 프로토콜을 지원하는 Daemon
- Http의 프로토콜을 받아드리고 http요청을 보낼 수 있도록 하는 구현체
- 즉, Http를 지원하는 서버이며, Web Server를 구축한다는 말은 httpd를 수행하는 말과 같다.
- EX) Apache Server도 Linus의 기본 httpd이다

### Background Process

- 입력장치에 대해 터미널과 관계를 끊은 모든 프로세스
- 눈에는 보이지 않지만 background에섬 묵묵히 할 일을 하는 프로세스

### Daemon

- 서비스 요청에 대해 응답하는 오랫동안 실행중인 Background Process
- 부팅 때 자동으로 켜저 Background에서 계속 실행하면서 꺼지지 않고 실시간으로 클라이언트와 통신을 계속 해야하는 서버 프로세스
- 시스템 구동시키기 위해서 필수적으로 백그라운드에서 돌아야 되는 프로세스

### 프로세스와 스레드

프로세스 및 스레드는 실행 파일 자체가 아니라 OS 상에서 시행돼서 어느정도 독립성을 가지고 동작한다.

- 활동하기 위해서는 메모리 공간이 필요하고 커널에 의해 메모리 상으로 확보가 된다.
- 메모리 공간을 통해서 데이터를 주고 받고 사용할 수 있다.
- 메모리 공간은 프로세스 시작 시에 공간이 확보가 된다.

프로세스 시작

1. OS 상에서 프로세스가 시작되서 사용자 요청을 받을 수 있다.
2. 시작 의뢰가 있으면 커널이 프로세스를 요청하고 요청 분량 만큼 메모리를 할당한다.
3. 프로그램은 서버 내부의 디스크 상에 설치된다.

- 하나의 프로세스가 동작하고 있으면 메모리 공간을 점유하는 스레드 하나가 동작하고 있다.
- 각 스레드는 메모리 공간을 공유 한다. 스레드 시작시에는 신규 메모리 공간은 필요 없지만, 다른 스레드에 이상이 발생하면 영향을 미친다.

논리 구성

- 웹 서버: OS안에 httpd 프로세스들로 이루어져 있다.
- AP 서버: OS안에 스레드들이 하나의 메모리 공간을 공유하고 있다.
- DB 서버: DB안에 공유메모리들이 존재하고 여러 프로세스들이 참조한다

- 각 서버들은 스위치를 경유해서 연결되어 있다.

### OS 커널

OS에서 커널 자체를 '인프라'이다.

- 하드웨어와 응용 프로그램 간의 인터페이스 역할을 수행한다.
  - 사용자 수준의 소프트웨어와 하드웨어 간의 통신을 관리한다.
  - 인터페이스로써 응용프로그램 수행에 필요한 여러가지 운영체제 서비스를 제공하며, 메모리 주소 공간등 리소스를 관리한다.
- 뒤에서 일이 벌어지는지 은폐하면서도 편리한 인터페이스를 가진다.
- 커널이 존재하기 때문에 개발자는 하드웨어나 다른 애플리케이션에 끼치는 영향을 의식하지 않고 애플리케이션을 만들 수 있다.
- OS 커널의 역할
  - 시스템콜 인터페이스
  - 프로세스 관리
  - 메모리 관리
  - 네트워크 스택
  - 파일 시스템 관리
  - 장치 드라이버

### 시스템 콜 인터페이스

프로세스나 스레드로 부터 명령을 받는 인터페이스

- User Mode Application이 Kernel Mode로 변경한 상태에서 OS 운영체제 서비스를 호출하는 것
- 애플리케이션이 OS를 통해 어떤 일을 처리하고 싶으면 시스템 콜이라는 명령을 이용해서 커널에 명령을 내린다.
  - 시스템 콜: 커널 영역의 기능을 사용자 모드가 사용 가능 하도록 한다.
    - 프로세스가 하드웨어에 직접 겁근해서 필요한 기능을 사용할 수 있게 해준다.
- 디스크 읽기 쓰기는 네트워크 읽기 쓰기와 같이 프로세스 관점에서 동일한 시스템 콜이다

### 커널 구성 방식

1. 모놀로식 커널: OS의 주요 구성 요소를 모두 하나의 메모리 공간을 통해 제공한다
2. 마이크로 커널: 다양한 OS 서비스들을 User Mode에서 처리하는 커널 구조

- 핵심 서비스를 제외하고 나머지는 가볍게 만든 최소한의 커널이다.

### 3계층형 서비스 전체 경로

클라이언트 PC -> 웹 서버

1. 웹 브라우저가 요청을 발행: PC의 웹 브라우저에서 OS 프로세스 실행, OS는 시스템 콜을 통해 네트워크 연결
2. 이름 해석: DNS 서버에 저장되어 있는 최신 IP 주소 받기
3. 웹 서버가 요청을 접수: httpd 프로세스가 http 요청을 판단한다.
4. 웹 서버가 동적인지 정적 콘텐츠 인지 판단: http, css이면 정적 컨텐츠 반환, 동적이 있으면 AP 서버에 데이터 요청
5. 필요한 경로로 데이터 엑세스

웹 서버 -> AP 서버

6. 동적 콘턴체를 소화하기 위해 웹 서버로 부터 요청을 받는다: JVM이라는 하나의 큰 프로세스에서 하나의 스레드 요청을 받는다.
7. 스레드가 요청을 받으면 자신이 계산할지, DB 접속이 필요한지 판단
8. DB 접속이 필요하면 연결 풀에 엑세스 한다
9. DB 서버에 요청을 던진다.

AP 서버 -> DB 서버 -> AP 서버

10. AP 서버로 부터 요청이 도착한다
11. 프로세스가 요청을 접수하고 캐시가 존재하는지 확인한다: 메모리에 캐시로 존재하는 데이터와 디스크에 있는 데이터를 정기적으로 동기화 하는 프로세스도 있다, 분업을 통해 처리량을 향상 시킬 수 있다

12. 캐시에 없으면 디스크에 엑세스 한다
13. 디스크가 데이터를 반환한다
14. 데이터를 캐시 형태로 저장한다
15. 결과를 AP 서버에 반환한다

AP 서버 -> 웹 서버

16. DB서 서버로부터 데이터가 도착한다
17. 스레드가 데이터를 가지고 계산 등을 한 후에 파일 데이터를 생성한다
18. 결과를 웹 서버로 반환한다

웹 서버 -> 클라이언트 PC

19. AP 서버로 부터 데이터가 도착한다
20. 프로세스는 받은 데이터를 그대로 반환한다
21. 결과를 웹 브라우저에 반환되고 화면에 표시한다
