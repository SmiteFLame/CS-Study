# Backend 개발자가 되기 위한 CS 지식 요약

## 자바

### 자바의 특징

1. 자바는 객체 지향 프로그래밍이 가능한 언어이다
2. JVM위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행한다
3. 고성능, 바이트 코드로 변환이 가능하다, 멀티 스레딩이 가능하다
4. 자동 메모리 관리(GC)가 가능하다

### 자바 컴파일러

자바를 가지고 작성한 코드는 자바 가상 머신이 이해할 수 있도록 바뀐다

### 자바 바이트 코드

자바 가상머신이 이해할 수 있는 언어로 변환된 자바 코드

### JVM

자바 가상머신으로 자바 애플리케이션을 클래스 로더를 통해서 읽는다

1. Interpreter - 자바 컴파일러에 의해 자바 바이트 코드를 읽는 역할
2. Class Loader - 동적으로 클래스를 로딩해주는 역할
3. Just-In-Time Compiler - 자바 컴파일러가 생성한 바이트 코드를 런타임에 바로 기계어로 변역
4. Garbarge Collector - 더 이상 사용하지 않는 메모리를 자동으로 회수

### JAVA의 메모리 영역

1. Class Area - JVM에 가장 먼저 올리는 공간, CLass와 Static(클래스 로딩)
2. Stack Area - 지역변수와 매개변수가 저장, 매서드 호출이 끝나면 모든 변수가 스택에서 제거
3. Heap Area - new 명령을 통해 생성된 인스턴스 변수
4. PC Register - Thread가 생성될 때 마다 생성
5. Native Method Stack- 자바외 언어로 작성된 네이티브 코드를 위한ㅇ 메모리

- 참조 변수에 저장되는 메모리 - Stack
- 그 주소를 가르키는 메모리 - Heap

메모리 관리 - GC을 수행하는 스택 기반의 가상머신
클래스 로더 - 클래스를 처음 참조할 때 해당 클래스를 로드하고 링크

## 객체지향

### OOP의 5원칙

1. 단일 책임 원칙 - 하나의 클래스는 하나의 책임만 갖는다
2. 개방 폐쇠 원칙 - 확장에는 열려 있고 변경에는 닫혀 있어야 한다
3. 리스코프 치환 원칙 - 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다
4. 의존 역전의 원칙 - 의존 관계를 맺을 때 구체적인 것(클래스)보다 추상적인 것(추상클래스, 인터페이스)에 의존해야 한다
5. 인터페이스 분리의 법칙 - 하나의 일반적인 인터페이스보다, 여러개의 인터페이스가 낫다

### 4가지의 특징

1. 캡슐화 - 하나의 객체에 대해 그 객체가 특정한 목적을 위한 변수나 메서드를 하나로 묶는 것
2. 상속 - 자식 클래스가 부모 클래스의 특성과 기능을 물려 받는 것
3. 추상화 - 인터페이스로 클래스들의 공통적인 특성을 묶어 표현하는 것
4. 다형성 - 형태가 같은데 다른 기능을 하는 것

## 데이터베이스

### 데이터무결성

데이터베이스에서 데이터들이 정확성, 일관성, 유효성을 유지하는 것

### 트랜잭션

하나 이상의 쿼리가 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 돌릴 수 있다.

### 트랜잭션의 ACID

- 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다
- 일관성: 트랜잭션에 수행하기 전이나 후에 데이터베이스는 항상 일관됭 상태여야 한다.
- 고립성: 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성: 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

### DB락

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근할 때 이를 제어해 준다
  - 공유 락: 데이터를 읽을 수 있지만 쓸 수 없다
  - 배타 락: 데이터를 읽고 쓸 수 있음

### 인덱스

추가적인 쓰기 작업과 저장 공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

- 장점: 조회 속도 및 성능 향상, 시스템 부하 감소
- 단점: 관리하기 위한 10% 저장 공간 필요, 추가작업 필요, 잘못 하면 오히려 성능 저하

- 해시테이블: 컬럼의 값으로 생성된 기반의 인덱스 구현, 검색 속도 O(1), 순차 검색 X
- B+ Tree: LinkedList로 연결하여 순차 검색이 가능, 해시 테이블보다 속도가 낮음

### 뷰

실제 데이터가 없는 테이블, 사용자의 편의와 보안 떄문에 사용

### 정규화

- 1: 각 컬럼들의 값이 원자값을 가진다
- 2: 테이블의 모든 컬럼에서 부분 함수적 종속을 제거
- 3: 기본키를 제외한 속성들간 이행적 함수 종속을 제거
- BCNF: 결정자이면서 후보키가 아닌 것들 제거

### 관계형 데이터베이스 VS NoSQL

- RDBMS: 2차원의 행과 열로 데이터 관계
  - 스키마에 맞춰서 관리 -> 정합성 보장
  - 시스템이 커질 수록 쿼리가 복잡, 성능 저하
- NoSQL: 비정형 데이터 일때 사용
  - 스키마가 없이 Key-Value로 더 자유롭게 관리 가능
  - 중복된 데이터가 추가 가능하며, 이에 대한 괸리가 편히

### 데이터베이스 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - commit한 데이터만 수정 허용
3. Repeatable Read - 다른 트랜잭션 사용 중 수정, 삭제 불가
4. Serializable - 다른 트랜잭션 사용 중 삭제, 수정, 삭제 불가

### 문제점

1. Dirty Read - 트랜잭션 작업이 완료 되지 않아도 트랜잭션에서 볼 수 있는 현상
2. Non-RepeatedRaed - 트랜잭션의 조회가 처음과 마지막이 다를 수 있다.
3. Phantom Read - 테이블이 같은 쿼리를 두 번 수행시 없는 레코드가 두번째 나오는 경우

### Delete VS Trucate VS Drop

- Delete: 데이터만 삭제, 전체 혹은 일부만 삭제, 롤백 가능, 삭제 행수 반환
- Trucate: 데이터와 인덱스 전체 삭제, 롤백 불가능, 삭제 행수 미 반환
- Drop: 테이블의 구조 자체를 삭제, 롤백 불가능
