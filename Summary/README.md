# Backend 개발자가 되기 위한 CS 지식 요약

## 자바

### 자바의 특징

1. 자바는 객체 지향 프로그래밍이 가능한 언어이다
2. JVM위에서 실행되기 때문에, 플랫폼에 의존하지 않고 실행한다
3. 고성능, 바이트 코드로 변환이 가능하다, 멀티 스레딩이 가능하다
4. 자동 메모리 관리(GC)가 가능하다

### 자바 컴파일러

자바를 가지고 작성한 코드는 자바 가상 머신이 이해할 수 있도록 바뀐다

### 자바 바이트 코드

자바 가상머신이 이해할 수 있는 언어로 변환된 자바 코드

### JVM

자바 가상머신으로 자바 애플리케이션을 클래스 로더를 통해서 읽는다

1. Interpreter - 자바 컴파일러에 의해 자바 바이트 코드를 읽는 역할
2. Class Loader - 동적으로 클래스를 로딩해주는 역할
3. Just-In-Time Compiler - 자바 컴파일러가 생성한 바이트 코드를 런타임에 바로 기계어로 변역
4. Garbarge Collector - 더 이상 사용하지 않는 메모리를 자동으로 회수

### JAVA의 메모리 영역

1. Class Area - JVM에 가장 먼저 올리는 공간, CLass와 Static(클래스 로딩)
2. Stack Area - 지역변수와 매개변수가 저장, 매서드 호출이 끝나면 모든 변수가 스택에서 제거
3. Heap Area - new 명령을 통해 생성된 인스턴스 변수
4. PC Register - Thread가 생성될 때 마다 생성
5. Native Method Stack- 자바외 언어로 작성된 네이티브 코드를 위한ㅇ 메모리

- 참조 변수에 저장되는 메모리 - Stack
- 그 주소를 가르키는 메모리 - Heap

메모리 관리 - GC을 수행하는 스택 기반의 가상머신
클래스 로더 - 클래스를 처음 참조할 때 해당 클래스를 로드하고 링크

## 객체지향

### OOP의 5원칙

1. 단일 책임 원칙 - 하나의 클래스는 하나의 책임만 갖는다
2. 개방 폐쇠 원칙 - 확장에는 열려 있고 변경에는 닫혀 있어야 한다
3. 리스코프 치환 원칙 - 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다
4. 의존 역전의 원칙 - 의존 관계를 맺을 때 구체적인 것(클래스)보다 추상적인 것(추상클래스, 인터페이스)에 의존해야 한다
5. 인터페이스 분리의 법칙 - 하나의 일반적인 인터페이스보다, 여러개의 인터페이스가 낫다

### 4가지의 특징

1. 캡슐화 - 하나의 객체에 대해 그 객체가 특정한 목적을 위한 변수나 메서드를 하나로 묶는 것
2. 상속 - 자식 클래스가 부모 클래스의 특성과 기능을 물려 받는 것
3. 추상화 - 인터페이스로 클래스들의 공통적인 특성을 묶어 표현하는 것
4. 다형성 - 형태가 같은데 다른 기능을 하는 것

## 데이터베이스

### 데이터무결성

데이터베이스에서 데이터들이 정확성, 일관성, 유효성을 유지하는 것

### 트랜잭션

하나 이상의 쿼리가 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 돌릴 수 있다.

### 트랜잭션의 ACID

- 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다
- 일관성: 트랜잭션에 수행하기 전이나 후에 데이터베이스는 항상 일관됭 상태여야 한다.
- 고립성: 수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성: 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

### DB락

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근할 때 이를 제어해 준다
  - 공유 락: 데이터를 읽을 수 있지만 쓸 수 없다
  - 배타 락: 데이터를 읽고 쓸 수 있음

### 인덱스

추가적인 쓰기 작업과 저장 공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

- 장점: 조회 속도 및 성능 향상, 시스템 부하 감소
- 단점: 관리하기 위한 10% 저장 공간 필요, 추가작업 필요, 잘못 하면 오히려 성능 저하

- 해시테이블: 컬럼의 값으로 생성된 기반의 인덱스 구현, 검색 속도 O(1), 순차 검색 X
- B+ Tree: LinkedList로 연결하여 순차 검색이 가능, 해시 테이블보다 속도가 낮음

### 뷰

실제 데이터가 없는 테이블, 사용자의 편의와 보안 떄문에 사용

### 정규화

- 1: 각 컬럼들의 값이 원자값을 가진다
- 2: 테이블의 모든 컬럼에서 부분 함수적 종속을 제거
- 3: 기본키를 제외한 속성들간 이행적 함수 종속을 제거
- BCNF: 결정자이면서 후보키가 아닌 것들 제거

### 관계형 데이터베이스 VS NoSQL

- RDBMS: 2차원의 행과 열로 데이터 관계
  - 스키마에 맞춰서 관리 -> 정합성 보장
  - 시스템이 커질 수록 쿼리가 복잡, 성능 저하
- NoSQL: 비정형 데이터 일때 사용
  - 스키마가 없이 Key-Value로 더 자유롭게 관리 가능
  - 중복된 데이터가 추가 가능하며, 이에 대한 괸리가 편히

### 데이터베이스 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - commit한 데이터만 수정 허용
3. Repeatable Read - 다른 트랜잭션 사용 중 수정, 삭제 불가
4. Serializable - 다른 트랜잭션 사용 중 삭제, 수정, 삭제 불가

### 문제점

1. Dirty Read - 트랜잭션 작업이 완료 되지 않아도 트랜잭션에서 볼 수 있는 현상
2. Non-RepeatedRaed - 트랜잭션의 조회가 처음과 마지막이 다를 수 있다.
3. Phantom Read - 테이블이 같은 쿼리를 두 번 수행시 없는 레코드가 두번째 나오는 경우

### Delete VS Trucate VS Drop

- Delete: 데이터만 삭제, 전체 혹은 일부만 삭제, 롤백 가능, 삭제 행수 반환
- Trucate: 데이터와 인덱스 전체 삭제, 롤백 불가능, 삭제 행수 미 반환
- Drop: 테이블의 구조 자체를 삭제, 롤백 불가능

### 트랜잭션

하나의 논리적인 기능을 수행하기 위한 작업의 단위, 데이터베이스의 일관 상태를 변환 시키는 기능을 수행

- A(원자성): 트랜잭션에서 수행된 내용은 전부 수행이 되거나 전부 수행이 되면 안된다
- C(일관성): 트랜잭션을 수향하기 전이나 후에는 데이터베이스가 항상 일관된 상태여야 한다, 무결성 제약이
- I(고립성): 트랜잭션이 수행디는 동안 다른 트랜잭션이 끼어들어서 값을 훼손하면 안된다
- D(지속성): 수행을 성공적으로 완료한 트랜잭션은 변경한 트랜잭션을 영구히 저장해야 한다

## 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리하고 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공해주는 프로그램들의 모임
- 컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다

### 프로그램 VS 프로세스 VS 스레드

프로그램

- 파일 시스템에 존재하는 실행 파일
- 동작되고 있지 않은 정적인 객체

프로세스

- 실행중인 프로그램으로 주소공간, 파일, 메모리등을 할당받아서 이것들을 총칭한다.
- 프로그램을 실행시켜주는 주체
- 동작하고 있는 동적인 객체

스레드

- 프로세스의 실행 단위로, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
- 프로세스가 할당받은 자원을 이용하는 실행 단위

### Context Switching

현재 진행하고 있는 Task의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정

- 하나의 Task가 끝날때 까지 다음 Task를 기다릴 수 없으므로 바꿔서 실행을 한다
- 순서
  - Task의 정보는 Register에서 저장되고 PCB에서 관리한다
  - 현재 실행하고 있는 Task의 PCB 정보를 저장한다(Process, Stack, Ready Queue)
  - 다음 실행할 PCB 정보를 읽어 Register에 적재하고 CPU 이전에 진행했던 과정을 연속으로 수행할 수 있다.
- Process가 Thread보다 수행 시간이 길다
  - Thread는 Stack 영역만 변경하면 된다

### Interrupt

프로그램을 실행하는 도중에 예기치 않은 상황이 발생하여 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행 중인 작업을 복귀

- 인터럽트 요청이 오면 Context Switching이 일어난다

### 멀티 프로그래밍 VS 멀티 프로세싱

멀티 프로그래밍

- 하나의 프로세서가 하나 이상의 프로그램을 동시에 수행시킨다.
- 여러 개의 프로그램을 메모리에 저장시켜놓고 프로세서를 빠르게 스위치하여 프로그램을 동작 시킨다.

멀티 프로세싱

- 여러개의 프로세스들을 가지고 하나 이상의 프로그램을 수행할 때 사용한다.
- 여러개의 프로세스가 협력하여 효율적이고 빠르세 프로그램을 진행할 수 있다.

### 멀티 프로세스 VS 멀티 스레드

멀티 프로세스

- 하나의 프로세스가 죽더라도 다른 프로세스에 영향이 없다
- 멀티 스레드보다 많은 메모리 공간과 CPU를 차지한다.

멀티 스레드

- 적은 메모리 공간을 차지하여 Context Switch가 빠르다
- 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료되는 동기화 문제가 있다

### 동시성 VS 병렬처리

동시성

- 단일 CPU 코어에서 두 개의 Task가 동시에 진행되는 것 처럼 보인다.

병렬 처리

- 둘 이상의 CPU 코어에서 두 개의 task가 동시에 진행된다.

### 스케쥴러

- 장기(Job): 저장되어 있는 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지
- 단기(CPU): Ready Queue에서 어떤 프로세스를 Running 할지
- 중기(Swapper): 여유 공간을 위해서 어떤 프로세스를 메모리에서 디스크로 보낼지

## 동기 VS 비동기

- 동기: 메소드 실행함으로써 반환값을 기대한다.
  - 반환 되기 전까지는 blocking 된다.
- 비동기: 메소드를 실행함으로써 반환값을 기대하지 않는다.

### Critical Section

멀티 Task 환경에서 하나의 Task가 자신의 Critical Section에서 수행을 하고 있으면 다른 Task는 그 Critical Section에 접근 할 수 없다

Critical Section의 3가지 조건

1. Mutual Exclusion(상호 배제) - Critical Section에 실행되고 있으면 다른 Task는 들어갈 수 없다.
2. Process(진행)- Critical Section에 진행되고 있는 Task가 없으면 Task가 들어갈 수 있다.
3. Bounded Waiting(한정된 대기) Critical Section 진입 횟수에 한계가 있어 계속 독점에서 사용할 수 없다.

해결 방법

1. Lock - Critical Section에 접근하면 Lock을 획득하고 Critical에 나오면 Lock을 방출 한다.

- 서로 연관된 프로세스들이 엉켜서 DeadLock이 생길 수 있다.

2. Mutex(Binary Semaphore) - Lock과 유사하지만, 무한 루프를 돌지 않고 기다리며 Context Switching을 실행한다.

- 오직 1개의 Task만 접근 할 수 있다

3. Count Semaphore - 정수값을 가지는 변수로 볼 수 있으며, 최대 접근 가능한 허용치를 준다.

- 세마포어의 변수만큼 Task에 접근 할 수 있다.

- 현재 수행중이 아닌 다른 프로세스가 Semaphore를 해제할 수 있다.

### DeadLock

둘 이상의 프로세스가 Critical Section 집입을 무한정 기다리고 Critical Section에 실행되는 프로세스는 진입 대기중인 프로세스가 실행되어야만 빠져 나올 수 있는 상태

교착 상태 조건

1. 상호 배제(Mutual Exclusion): 한 리소스는 한 번에 한 프로세스만을 사용할 수 있다.
2. 점유 대기(Hold and Wait): 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면 다른 프로세스가 가지고 있는 리소스를 기다리고 있음
3. 비선점(No Preemption): 프로세스가 Task를 마친 후 리소스를 자발적으로 반환 할대 까지 기다림
4. 환형 대기(Circular Wait): Hold and Wait 관계의 프로세스들이 서로 기다림

교창 상태 방지법

1. 방지(Prevention): 교착 상태가 발생할 수 있는 요구 조건을 만족시키지 않도록 한다.
2. 회피(Avoidance): 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않는다.

- 은행원 알고리즘, 자원 할당 알고리즘

3. 탐지 및 회복(Detection and Recovery): 교착 상태가 발생 할 수 있도록 놔 두고 교착 상태가 발생할 경우 찾아내어 고친다.

### 메모리 영역

1. 코드 영역: 실행할 프로그램의 코드가 저장되는 영역
2. 데이터 영역: Global, Static 변수가 저장되는 영역

- 프로그램 시작과 동시에 할당, 프로그램이 종료되면 소멸

3. 힙 역역: 프로그래머가 직접 관리할 수 있는 메모리 영역, 동적 할당되는 영역

- 코드 중에 변수가 선언이 되면 힙 영역에 할당된다.
- 메모리 크기 제한이 없고, 변수를 전역적으로 엑세스 할 수 있다.

4. 스택 영역: 함수의 호출과 함계 할당되며 지역 변수, 매개 변수가 저장되는 영역

- 함수의 호출이 완료되면 소멸한다.
- 4개의 메모리 중에서 가장 높은 주소에 할당이 된다.
- 매우 빠른 엑세스, 지역 변수만 되지만 크기 조정이 불가능하다.
- 공간은 CPU에서 관리하여 매우 효율적이다.

### 단편화

프로세스들 메모리 적재되고 제거 되면서 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 자유 공간들이 늘어나게 되는 형상

- 외부 단편화: 물리 메모리 사이 공간들을 합치면 충분하지만 분산되어 있는 경우
- 내부 단편화: 프로세스 사용하는 메모리 공간에 포함된 남는 부분

- 페이징: 외부 단편화 해결
  - 물리 메모리는 Frame이라는 고정 크기로 분리되고, 논리 메모리는 Page로 고정 크기 분리
- 세그멘테이션: 내부 단편화 해결
  - 서로 다른 크기의 논리적 단위인 Segment를 사용하여 두 개의 주소를 지정
- 페이징은 가상 메모리에서도 물리 메모리와 마찬가지로 고정된 크기의 프레임 단위를 나눠서 관리
- 세그멘테이션은 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위로 분할

### 가상 메모리

프로세스 전체를 메모리에 올리지 않아도 실행할 수 있도록 하는 기법

- 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다.
- 작은 메모리를 가지고도 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.

페이지

- 가장 메모리를 일정한 크기로 나눈 블록

페이지 폴트

- 프로그램이 자신의 주소 공간에는 존재하지만 시스템의 RAM에는 없는 데이터나 코드에 접근을 시도한 경우 발생
- 페이지 폴트가 발생하면 OS는 그 데이터를 메모리에 가져와서 마치 페이지 폴트가 전혀 발생하지 않는 거서럼 프로그램이 계속 동작하게 해준다.

### 시스템 콜

운영체제의 서비스에 접근하기 위한 인터페이스

- 권한이 낮은 응용 SW 커널에 제공하는 서비스를 사용하는 방법

커널

- 부팅되는 동안 메모리르 로드하는 OS의 첫 부분
- 지속적으로 읽어들일 수 있도록 되어 있으며, 메모리 상에서 사용자가 접근할 수 없도록 커널 영역에서 보호된다.

## Spring

JAVA의 웹 프레임 워크로 JAVA 기술들을 더 쉽게 사용할 수 있게 해주는 오픈 소스 프레임 워크

- 프레임 워크: 자주 쓰이는 기능들을 모아 놓은 유틸들의 모음

- IOC: 객체 생명주기 관리를 개발자가 하는게 아닌 스프링(컨테이너) 대신 해주는 것
  - New 연산자, 인터페이스 호출, 데이터 클래스 호출을 대신 관리
- DI: 구성요소 간의 의존 관계가 소수 내부가 아닌 외부 파일을 통해 정의
  - XML을 통한 주입, 생성자를 통한 주입, 속성을 통한 주입, Autowired를 통한 주입
- AOP: 여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법
- POJO: Getter, Setter를 가진 단순한 자바 오브젝트

IOC - 객체의 흐름, 생명주기 관리를 독립적인 제 3자에게 역할과 책임을 위임하는 방식

DI - 인터페이스를 통해 다이나믹 하게 객체를 주입하여 유연한 프로그래밍을 가능하게 한다.

### Spring Boot

단독으로 실행되는 상용화 가능한 수준의 스프링 기반 애플리케이션을 쉽게 만든다.

- WAS에 대한 설정 없이 바로 개발에 들어갈 수 있도록 만든 프레임 워크
- 스프링 프레임워크를 사용하려면 많은 XML 설정 파일들을 장성해야하고, 기존에 사용했던 설정들을 copy and paste하거나 검색을 통해 일일이 설정을 해야하나 스프링 부트를 사용하면 복잡한 설정 없이 쉽고 빠르게 프레임워크를 사용할 수 있다.

### Spring MVC

Model-View-Controller으로 구성이 되어 있는 있다.

- Web Server에 특화되어 만들어진 모듈로, 개발자가 해야할 영역을 더 적게 만들어 준다.
- Model: '데이터'의 디자인을 담당, 최대한 구체적이고 작은 Entity를 유지
- View: 실제 랜더링 되어 보이는 페이지, HTML, 도메인 모델의 상태를 변환하거나 받아서 렌더링
- Controller: Model과 View를 연결해주면서 동작 순서나 방식을 제어한다.

- 장점: 도메인을 작은 역할 단위로 분리하여 설계하는 작업으로 분리되어 각자의 역할에 집중할 수 있다.
- 단점: Model과 View의 완벽한 분리가 힘들다

### Spring 동작 순서

1. Client는 URL을 통해 Request한다.
2. DispatcherServlet는 HandlerMapping을 통해 Request가 어느 Controller에게 온 요청인지 찾는다.
3. DispatcherServlet는 HandlerAdapter를 통해 Request를 전달을 맡긴다.
4. HandlerAdapter는 해당 Controller에게 Request를 전달한다.
5. Controller는 로직을 처리한후 반환할 View의 이름을 반환한다.
6. DispatcherServlet는 ViewResolover를 통해 반환할 View를 찾는다.
7. DispatcherServlet는 Controller에서 View에 전달할 데이터를 추가한다.
8. 데이터가 추가된 View를 반환한다.

### Annotation

- Component: Spring에서 관리하는 객체임을 표시하는 기본적인 Annotation
- Service: 서비스 레이어로 주로 내부의 자바 로직을 처리한다.
- Repository: DB나 파일 같은 외부 I/O 작업을 처리한다
- Controller: View에 주로 반환하기 위해서 사용한다.
  - 데이터를 반환하는 경우 ResponseBody를 사용한다.
- RestController: Controller에 ResponseBody를 추가하여 JSON 형태의 객체를 반환하기 위해 사용한다.

## Infra

### 3계층형 아키텍처

1. 프레젠테이션 계층: 사용자의 입력을 받고 브라우저에 표시

- 주로 웹 서버를 의미한다.

2. 애플리케이션 계층: 사용자의 요청에 따라 업무를 처리한다.

- 주로 앱 서버를 의미한다.

3. 데이터 계층: 애플리케이션 계층의 요청에 따라 입출력한다.

- 주로 데이터베이스 서버를 의미한다.

장점

- 서버 주하 집중이 개선된다.
- 클라이언트 단말의 정기 업데이트가 불필요하다
- '처리 반환'에 의한 서버 부하가 절감된다.
- 웹 디자이너, 소프트웨어 엔지니어, DB 관리자가 역할 분담을 하여 일을 효율적으로 할 수 있다.

### 서버

클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 시스템으로 컴퓨터 프로그램, 장치를 의미한다.

구성

- PC와 물리적으로 기본적 구성이 같다.
- CPU, 메모리 저장장치등을 가지고 있고 클라이언트의 요청에 대응하기 위해 고성능을 갖추고 있다.
- CPU: 서버 중심에 연산 처리를 실시한다. 명령과 데이터는 기억 장치나 입출력 장치를 통해 전달된다.
- 메모리: 기억 명령을 수행한다. CPU 옆에서 전달하는 내용이나 데이터를 저장하거나 처리 결과를 받는다.
