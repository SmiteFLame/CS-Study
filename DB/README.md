# 데이터베이스

## 데이터베이스 튜닝

데이터베이스 응용, 데이터베이스 자체, 운영체제의 조정등을 통하여 최적의 자원으로 최적의 성능을 얻을 수 있도록 개선하는 작업

1단계 - DB설계 튜닝(모델링 관점)

- 데이터베이스 설계 단계에서 성능 고려하여 설계
- 데이터 모델링, 인덱스 설계
- 데이터 파일, 데이터 스페이스 설계
- 데이터베이스 용량 산정

2단계 - DBMS 튜닝(환경관점)

- 성능을 고려하여 메모리나 블록 크기 지정
- CPU, 메모리 I/O에 관한 관점

3단계 - SQL 튜닝

- SQL 작성시 성능 고려
- Join, Indexing, SQL Exeution Plan

## 데이터 모델링

- 모델: 일정한 표기법에 따라 표현한 모형, 축소형
- 모델링: 모델을 만들어가는 일 자체를 나타낸다.

### 모델링 3대 특징

- 단순화: 누구나 쉽게 이해할 수 있도록 표현한다
- 명확화: 명확하게 한 가지 의미로 해석되어야 한다.
- 추상화: 현실 세계를 간략하게 표현한다

## 데이터 모델

- 개념 데이터 모델: 추상화 수준이 높고, 업무 중심적으로 포괄적인 수준의 모델링
- 논리 데이터 모델: 업무에 대한 키, 속성, 관계 등을 정확하게 표현
- 물리 데이터 모델: 데이터베이스 이식을 위해, 성능, 저장 등 물리 요소를 고려하여 설계

## 엔터티

- 변별할 수 있는 사물
- 데이터베이스 내에서 변별 가능한 객체
- 정보를 저장할 수 있는 어떤 것

- 엔터티는 인스턴스의 집합이다.
- 각 인스턴스들의 성격을 구체적으로 설명하는 항목이 속성이고, 식별자는 엔터티의 여러 속성 중 각 인스턴스를 유일하게 식별할 수 있는 하나 이상의 속성을 의미한다.

## 속성

### 식별 관계

- 식별관계: 부모 엔티티의 식별자를 자식 엔티티의 식별자로 상속
  - 즉, 외래키를 이용하여 다른 테이블의 기본키로 사용하게 된다면 식별관계이다.
- 비식별관계: 일반속성으로 상속

## 관계

개념 모델 단계에서 정의한 M:M 관계는 논리 모델 단계에서 관계 엔터티로 재정의 해야 한다.

- 즉, 양쪽 엔터티로부터 식별자로 상속받은 제 3의 교차 엔터티를 정의해야한다.

- 부모 엔티티 기준
  - 자식 엔터티를 필수 관계(O가 없음)로 정의한다면, 부모 인스턴스별로 자식 인스턴스를 반드시 등록한다.
  - 자식 엔터티를 선택 관계(O가 있음)로 정의한다면, 부모 인스턴스만 등록하고 자식 인스턴스를 등록하지 않아도 된다.
- 자식 엔티티 기준
  - 부모 엔터티를 필수 관계(O가 없음)로 정의한다면, 부모 인스턴스를 먼저 등록한 후에 자식 인스턴스를 등록 해야 한다.
  - 부모 엔터티를 선택 관계(O가 있음)로 정의한다면, 부모 없이 자식 인스턴스만 등록(FK에는 NULL)할 수 있다.

## 식별자

### 주 식별자의 특징

- 유일성: 엔터티의 모든 인스턴스를 고유하게 식별할 수 있어야 함
- 최소성: 고유성을 만족하는 최소의 속성으로 구성되어야 함
- 불변성: 주 식별자의 속성이 변경되지 않아야 함
- 존재성: 주 식별자의 속성에 NULL을 입력할 수 없음

### 표기법

- IE
  - 점선: 비식별관계를 표현한다
- 바커
  - 실선: 식별관계
  - 점선: 비식별관계

## 무결성

데이터베이스에서 데이터들이 정확성, 일관성 , 유효성을 유지하는 것을 말합니다.

다양한 무결성이 존재하는 데, 몇 개의 예를 들면 Null 무결성같은 경우는 특정 속성값에 null값이 데이터가 들어갈 수 없는 무결성이고, 고유 무결성 같은 경우 특정 속성에 고유한 값을 가지는 무결성입니다 또한 개체 무결성, 기본키는 빈 값이 들어가면 안된다. 참조 무결성 서로 참조 관계에 잇는 두 테이블은 항상 일관된 값을 유지한다 등 다양한 무결성이 있습니다.

무결성이 유지되면서 DB에 저장된 값과 해당되는 실제 값이 일치하는지 신뢰할 수 있습니다.

### 무결성의 종류

1. 개체 무결성 - 즉 NULL값 허용 불가, 중복 허용 불가
2. 참조 무결성 - 외래키 값은 NULL이거나 참조 기본키값과 동일해야 함
3. 도미엔 무결성 - 특정 속성의 값이 그 속성이 정의된 도메인에 속해야 한다.
4. 고유 무결성 - 값이 중복 불가능한 속성인 경우, 그 속성 값은 모두 달라야 한다는 제약 조건
5. NULL 무결성 - NULL값이 불가능한 속성인 경우, 그 속성 값은 NULL이 들어갈 수 없다.
6. 키 무결성 - 한 테이블에는 최소한 하나의 키가 존재해야 한다는 조건

## 트랜잭션

- 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법이다.
- 하나의 논리적인 기능을 수행하기 위한 작업의 단위로써, 데이터베스의 일관된 상태를 변환 시키는 기능을 수행합니다.

### 트랜잭션의 ACID

- 원자성 - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야한다.
- 일관성 - 트랜잭션을 수행하기 전이나 후에 데이터베이스는 항상 일관된 상태여야 한다.
- 고립성 - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성 - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### 트랜잭션 병행 제어

병행 제어: 동시에 여러 트랜잭션을 병행으로 처리할 때 일관성을 유지하도록 트랜잭션 간 상호 작용을 제어하는 기술

- 공유를 최대화, 시스템 활용도 최대화, 응답시간 최소화, 일관성 유지를 목적으로 한다

### 트랜잭션 병행처리 후 문제

갱신 내용 손실 - 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우

현황 파악 오류 - 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우

모순성 - 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제

연쇄 복귀 - 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

## 이상현상

- 갱신이상: 반복된 데이터 중 일부를 갱신할 때 불일치 발생
  - 하나의 컬럼이 변경되었을 떄 관련된 모든 컬럼을 모두 변경하지 않는 경우 갱신 이상 발생
- 삽입이상: 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능
  - 1,2,3,4 속성을 넣어야 되지만 1,2,3 속성 값만 존재하여 4 속성 필드값을 결정 못하는 경우
- 삭제이상: 필요한 정보를 함꼐 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능
  - 원하는 속성값만 지우고 싶지만 컬럼을 전부 지우게 되는 경우

## DB락의 종류

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구

공유 락 - 트랜 잭션 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

베타 락 - 트랜 잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

- 인덱스는 항상 최신 정렬된 상태를 유지를 해야 한다.
- INSERT: 새로운 데이터에 대한 인덱스를 추가한다.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

## 인덱스를 사용하는 이유

추가적인 쓰기 작업과 저장 공관을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.

장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다
- 인덱스를 관리하기 위해 추가 작업이 필요하다
- 인덱스를 잘못 사용하면 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 인덱스의 자료구조

- 해시테이블
  - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
  - 시간 복잡도 라서 O(1)이라 검색이 매우 빠르다.
  - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능
- B+ Tree
  - 자식 노드가 2개 이상인 B- Tree를 개선 시킨 자료구조이다.
  - BTree의 리프노드들은 LinkedList로 연결하여 순차 검색이 용이하게 하였다.
  - 해시 테이블보다 나쁜 시간복잡도를 가졌지만 해시테이블보다 흔하게 사용된다.
  - 알파벳을 기준으로 A F L 이 있다고 했을 때 B가 들어오면 A-F 사이 값이므로 A에 해당되는 인덱스로 들어가서 B라는 결과값을 가지고 온다

### 뷰를 사용하는 이유

테이블과 유사하지만 실제 데이터가 없는 테이블을 바로보는 매개체이다. 사용자의 편의와 데이터베이스의 보안때문에 사용한다. 원본 테이블에 직접 접근하지 않아도 사용자가 임의의 뷰를 구성하여 별도의 이름을 붙이거나 접근 가능한 사람을 지정하면서 사용자가 원하는 데이터만 보여주고 보안에 있는 데이터를 보여주지 않으면서 편리하게 사용할 수 있습니다.

## 정규화

1 - 각 컬럼들은 값이 원자값을 가지게 바꾼다.

2 - 테이블의 모든 컬럼에서 부분 함수적 종속을 제거한다.

3 - 기본키를 제외한 속성들간 이행적 함수 종속을 없앤다.

BCNF - 결정자이면서 후보키가 아닌 것들을 제거한다.

## 관계형 데이터베이스와 비 관계형 데이터베이스의 차이점을 설명하시오

관계형 데이터베이스는 테이블로 이루어져 있으며, 이 테이블은 키와 값의 관계로 나타난다. 이처럼데이터읮 종속성을 관계로 표현하는 것이 관계형 데이터베이스 이다. 반대로, 비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히 NoSQL이라고 하며 데이터를 저장할 때 sQL 문이 아니라 다른 프로그래밍 언어를 사용한다.

### RDBMS vs NoSQL

- RDBMS
  - 2차원의 행과 열로 데이터를 관계를 관리하는 데이터베이스
  - 장점 - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
  - 단점 - 시스템이 커질 수록 퀴리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.
- NoSQL
  - RDMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
  - 장점 - NoSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리한다.
  - 단점 - 중복된 데이터가 추가 가능하며, 이에 대한 관리가 필요하다.

### RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요

NoSQL의 큰 장점은 JOIN처리가 없어서 노드 확장이 용이하다 그리고 가변적인 데이터 구조를 저장할 수 있어서 훨씬 더 유연성이 높다. 반면에 쿼리가 불가능하고 일관성을 항상 보장할 수 없다.

속도적인 면은 MySQL, ORCLE도 최적화가 잘 되어있기 때문에 상황에 따라서 뭐가 더 좋다고 설명하기는 힘들다.

### 어떤 상황에서 NoSQL을 쓰는 것이 더 적합한가?

비정형 데이터를 저장해야할 때 가장 적합다.

## 격리수준

### 격리성 관련 문제점

1. Dirty Read - 트랜 잭션이 작업이 완료되지 않았는데도 다른 트랜 잭션에서 볼 수 있는 현상

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 발생
- 작업중인 트랜잭션2가 롤백하는 경우 트랜잭션 1은 무효가 된 데이터를 읽고 잘못된 결과를 도출

2. Non-RepeatedRead -트랜잭션의 조회가 처음과 마지막이 다르게 나올 수 있다.

- 트랜잭션 1이 데이터를 읽고 트랜잭션2가 UPDATE를 한 후에 트랜잭션 1이 다시 한번 데이터 읽는 경우
- 트랜잭션 1이 읽기 작업을 다시 한반 반복하는 경우 이전 결과와 다른 결과가 나오는 현상

3. Phantom Read - T!이 같은 쿼리를 두번 수행시 첫번째 실행시 없던 레코드가 두번째 나오는 경우

- 트랜잭션 1이 데이터를 읽고 트랜잭션2가 INSERT를 한 후에 트랜잭션 1이 다시 한번 데이터 읽는 경우
- 트랜잭션이 읽기 작업을 다시 한번 반복할 경우 이전에 없던 데이터가 나타는 현상

### 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - 다른 트랜잭션이 commit한 데이터만 수정만을 허용

- 자신이 데이터를 읽고 있는 동안 공유락을 검, 트랜잭션 끝나기 전에도 해지 가능

3. Repeatable Read - 다른 트랜잭션이 읽는 동안 삽입, 삭제 불가

- 자신의 데이터에 서정된 공유락, 배타락을 트랜잭션이 종료될 떄 까지 유지하여 수정 불가능 하도록 설정

4. Serializable - 다른 트랜잭션이 읽는 동안 삽입도 불가능, 동시 성능은 급격히 떨어질 수 있다.

- 실행중인 트랜잭션은 다른 트랜잭션으로 부터 완전히 분리한다

## Delete, Truncate, Drop

Delete(DML)

- 데이터만 삭제되며 테이블 용량이 줄어들지 않는다. 또한 데이터 삭제후 잘못된 것을 되돌릴수 있다.
- TABLE이나 CLUSTER에 행이 많으면 행이 삭제될 때마다 많은 시스템이 소모된다.
- Commit이전 롤백이 가능하다.
- 롤백 때문에 Truncate에 비해 느리다
- 전체 또는 일부만 삭제 가능
- 삭제 행수를 반환한다.

Truncate(DDL)

- 테이블을 최초 생성된 초기 상태를 만든다.
- 용량이 줄어들고, 인덱스 등도 모두 삭제된다.
- 전체 삭제만 가능한다.
- Rollback이 불가능하다.
- 삭제행수를 반환하지 않는다.

Drop(DDL)

- 기존 테이블의 존재를 제한다
- Rollback이 불가능하다
- 테이블의 정의 자체를 완전히 삭제한다.

## Connection Pool

WAS가 실행되면서 DB와 미리 Connection(연결)을 해놓은 객체들을 Pool에 저장해 두었다가 클라이언트의 요청이 오면 Connection을 빌려주고, 처리가 끝나면 Pool에 반납하는 형식

- Connection Pool에서 Connection 정보를 관리하기 때문에 DB 연결을 위한 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다

### DBCP(DataBase Connection Pool)

DB와 커넥션을 맺고 있는 객체를 관리하는 역할

- WAS가 실행되면서 Connection 객체를 미리 Pool에 생성해 둔다
- HTTP 요청에 따라 pool에서 Connection 객체를 가져다 쓰고 반환한다
- 물리적인 데이터베이스 Connection 부하를 줄이고 연결 관리한다
- Pool에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 데 드는 요청마다 연결 시간이 소비되지 않는다
- 커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수를 제한적으로 설정한다

- MIN 설정 이유: 평상시에 유지할 최소 idle의 개수
  - Connection Overhead를 프로그램을 시작할 때 한 번에 끝낸다
- MIN, MAX를 동일하게 하는 이유: 마친가지로 Connection을 계속 추가로 연결하게 되는 오버헤드를 줄이기 위해서

## 잠금

각 트랜잭션은 사용하는 데이터에 대한 엑세스를 Reservation(예약)한다

- Share Lock(공유 잠금 / Read Lock): 다른 사용자가 같이 읽는 것을 허용하지만 변경하는 것은 허용하지 않음
  - 공유 잠금끼리는 서로 충돌되지 않는다
  - 공유 잠금을 사용시, 다른 트랜잭션이 데이터를 변경할 수 없다
- Exclusive Lock(베타적 잠금 / Write Lock): 다른 사용자가 읽는 것, 변경하는 것 모두를 허용하지 않음
  - 단독잠금이 걸린 데이터는 다른 트랜잭션이 공유 잠금, 단독 잠금 또한 걸 수 없다
  - 하나의 트랜잭션만이 데이터에 대한 단독 잠금을 걸 수 있다

### 비관적 락

트랜잭션이 시작될 때 Shared Lock 혹은 Exclusive Lock을 걸고 시작 하는 방법

- Write를 하기 위해서 Exclucvie Lock을 얻어야 하는데 Shared Lock이 걸려 있으면 해당 Lock을 얻지 못해 수행하지 못하고 트랜잭션이 종료된다
- 즉, 트랜잭션의 충돌이 발생할 것을 생각하여 락을 걸어둔다
- 데이터 수정할 때 특시 트랜잭션 충돌을 알 수 있다

- PESSIMISTIC_READ: 공유 락을 얻고 업데이트되거나 삭제 되지 않도록 방지
- PESSIMISTIC_WRITE: 배타적 락을 얻고 데이터를 읽거나, 업데이트, 삭제하는 것을 방지
- PESSIMISTIC_FORCE_INCREMENT: WRITE를 얻고 유사하게 작동되며, 엔티티의 버전 속성을 추가로 증가 시킨다

- 하나의 트랜잭션으로 묶어 있기 땜문에 실패를 하게 된다면 전체 Rollback이 일어난다

### 낙관적 락

DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock

- 데이터의 버전을 확인함으로써 버전이 변경된 경우에는 수정 요청을 반영하지 않는다
- 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다
- 장점
  - 성능적으로 더 효과적이다
  - 트랜잭션이 필요하지 않다
- 단점

  - 롤백하기 위해서는 수동으로 처리를 해줘야 한다

- OPTIMISTIC_FORCE_INCREEMENT: 낙관적 락을 사용하면서 버전 정보를 강제로 증가 시킨다
- Spring에서는 Entity 마다 @Version을 통해서 잠글 수 있다

- 서로 다른 종류의 데이터베이스를 업데이트하기 위해서는 낙관적 락을 사용한다

## 영속성 컨텍스트

엔티티를 영구 저장하는 환경

- EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있다

- 영속화 된 상태가 바로 DB에 저장되는 것이 아니다

  - commit을 하게 된다면 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날라간다

- JPA가 엔티티 객체들을 모아두는 공간

  - 엔티티 매니저는 관리하는 엔티티 객체들을 연속 컨텍스트에 넣어두고 객체들의 생사를 관리한다

- 비영속: 영속성 컨택스트와 관계가 없는 새로운 상태
- 영속: 엔티티 매니저를 통해 엔티티가 영속성 컨텍스트에 저장되어 관리되고 있는 상태
- 준영속: 영속성 컨택스트에서 관리되다가 분리된 상태
- 삭제: 영속성 컨텍스트에서 삭제된 상태

장점

- 1차 캐시
  - 엔티티를 영속 상태로 만든 후 다시 조회하는 경우 DB 접근이 아닌 영속성 컨텍스트에서 캐시된 내용을 조회 가능
- 동일성 보장
  - 동일한 영속성 컨텍스트내에서 동일한 키로 조회한 엔티티의 경우 같은 객체
- 쓰기 지연
  - JPA가 `entityManager.persist()`를 통해서 계속 쌓고 있는 상태
    - 쓰기 지연 SQL 저장소에 쌓는다
  - `transaction.commit()`을 통해서 쓰기 지연 SQL 저장소에 있는 Query들을 DB로 날린다
    - `flush()`를 하게 된다면 1차 캐시는 지우지 않는다
    - `flush()`후에 실제 DB Transaction에 commit된다
- 변경 감지
  - 엔티티의 수정 시 따로 쿼리 조작 메서드가 필요 없음
  - Entity 데이터 수정시 update나 persisit를 통해서 영속성 컨텍스트에 해당 데이터를

### Entity Mananger

특정 작업을 위해 데이터베이스에 엑세스 하는 역할

- Entity를 DB에 등록, 조회, 수정, 삭제하는 역할
- EntityManangerFactory를 트랜잭션 단위를 수행할 때 마다 생성된다
  - EntityManagerFactory는 DB당 단 하나만 생성이 되야 한다
- 고객의 요청이 올때마다 사용했다가 닫는다
- 내부에는 영속성 컨텍스트가 있으며 이를 통해서 관리한다
- 여러 엔티티 매니저가 하나의 영속성 컨텍스트르 공유한다

- 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 절대 공유하지 않는다

- 객체들의 Flush은 Transaction에서 관리를 하게 되고 여기서는 객체들의 생사를 관리하게 된다

### EntityTransaction

데이터를 변경하는 모든 작업은 반드시 Transaction안에서 이루어져야 한다

## Redis (REmote Dictionary Server)

비 관계형 데이터베이스, Key-Value나 컬럼, 문서 형싱의 데이터 모델이다

- 메모리 기반의 "키-값" 구조 데이터 관리 시스템이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장한다
- String, Set, Sorted Set, Hash, List의 데이터 형식을 지원한다

1. 영속성을 지원하는 인메모리 데이터 저장소
2. 읽기 성능 증대를 위한 서버 측 복제를 지원

- 실행중인 서버가 충돌하는 경우 장애 조치 처리와 함께 더 높은 읽기 성능을 지원하기 위해 슬레이브가 마스터에 연결
- 전체 데이터베이스의 초기 복사본을 받는 마스터 / 슬레이브 복제를 지원한다
- 마스터에서 쓰기가 수행되면 슬레이브 데이터 세트는 실시간으로 업데이트를 하기 위해 연결된 모든 슬레이브로 전송한다

3. 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원한다

- 파티셔닝(Partitioning)과 동일하다
- 같읕 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미한다

### 장점

1. 리스트, 배열과 같은 데이터를 처리하는데 유용하다

- value 값으로 String, Set, Sorted Set, Hash, List 등 여러 데이터 형식을 지원하기에 다양한 데이터를 활용할 수 있다.

2. 리스트형 데이터 입력과 삭제가 MySQL에 비해서 10배 정도 빠르다

- 여러 프로세서에서 동시에 같은 key에 대한 갱신을 요청할 경우, 원자성 처리로 데이터 부정합 방지 Atomic 처리함수를 제공한다

3. 메모리를 활용하면서 영속적인 데이터 보존

- 명령어로 명시적으로 삭제, expires를 설정하지 않으면 데이터를 삭제되지 않는다

4. Redis Server는 1개의 싱글 스레드로 수행되며, 따라서 서버 하나에 여러 개의 서버를 띄우는 것도 가능하다

## Hadoop

분산 환경에서 빅데이터를 저장하고 처리할 수 있는 자바 기반의 오픈소스 프레임 워크

- 하둡 소프트웨어 라이브러리는 간단한 프로그래밍 모델을 사용하여 여러 대의 컴퓨터 클러스터에 대규모 데이터 세트를 분산 처리할 수 있게 해주는 프레임 워크이다.

### 구성요소

1. 하둡 분산형 파일 시스템(HDFS)

- 하둡 네트워크 연결된 기기에 데이터를 저장하는 분산 시스템
- HDFS는 여러 기계에 대용량 파일을 나눠서 저장한다.
- 데이터를 여러 서버에 중복해서 저장함으로써 데이터 안정성을 얻는다.

  1. HDFS는 데이터를 저장하면, 다수의 노드에 복제 데이터도 함께 저장해서 데이터 유실을 막는다.
  2. HDFS에 파일을 저장하거나, 저장된 파일을 조회하려면 스트리밍 방식으로 데이터에 접근해야 한다.
  3. 한번 저장된 데이터를 수정할 수 없고 읽기만 가능해서 데이터 무결성을 유지한다.
  4. 데이터 수정은 불가능 하지만 파일 이동, 삭제, 복사할 수 있는 인터페이스르 제공한다.

  - Master/slave 구조를 통해서 하나의 네임 노드와 파일 시스템을 관리하고 클라이언트의 접근을 통제하는 마스터 서버로 구성된다.

2. 맵 리듀스(MapReduce)

- 대용량의 처리를 위한 분산 프로그래밍 모델, 소프트웨어 프레임워크
- 맵 리듀스 프레임워크를 이용하면 대규모 분산 컴퓨터 환경에서 대량의 데이터를 병렬로 분석 가능
- 프로그래머가 직접 작성하는 맵과 리듀스라는 두 개의 메소드로 구성

1. 흩어져 있는 데이터를 수직화
2. 그 데이터를 각각의 종류 별로 모은다(Map)
3. 필터링과 Sorting을 거쳐 데이터를 뽑아낸다(Reduce)

## Spark(Apache Spark)

인 메모리 기반의 대용량 데이터 고속 처리 엔진으로 범용 분산 클러스터 컴퓨팅 프레임 워크

- 인메모리: 데이터스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터베이스 방식 관리 시스템
  - 즉, 하드 디스크가 아닌 메인 메모리에 올려서 서비스를 수행 하는 것을 말한다.
  - 단점: 안정성이 떨어진다. 메인 메모리는 휘발성 주기억장치로, 정전이나 전력이 끊기면 메모리에 데이터가 사라지게 된다.
    - 백업을 통해서 계속 데이터를 저장해 두어야 한다.
- 다양한 언어 지원, JAVA, Scale, Python, R, SQL

### 구성 요소

1. Spark Core: 메인 컴포넌트로 작업 스케쥴링, 메모리 관리, 장애 복구와 같은 기본적인 기능을 제공하고, RDD, Dateset, DataFrame을 이용한 스파크 연산을 처리한다.
2. Spark Library: 빅데이터 처리를 위한 라이브러리
   - park SQL: 이를 이용하여 작업을 생성하고 처리한다.
   - park Streaming: 실시간 데이터 스트림을 처리하는 컴포넌트이다.
   - MLib: 스파크 기반의 머신러닝 기능을 제공하는 컴포넌트이다.
   - GraphX: 분산형 그래프 프로세싱이 가능하게 해주는 컴포넌트이다.
3. Cluster Manager: 스파크 작업을 운영하는 클러스터 관리지이다

## 단일 서버 VS 서버 분리

- 단일 서버: 웹 서버 WAS + DB 서버 합쳐서
- 서버 분리: 웹 서버 WAS 따로, DB 서버 따로

- WAS에서 처리할 부분이 DB서버에 비해 상대적으로 많은 경우 분리 하게 된다

1. 확장성: Scale out하기 위해서 DB 서버 분리는 반드시 필요한 과정 중 하나이다.
2. 보안성: 별도의 데이터베이스 서버를 통해 제한적인 권한을 부여한 경우 보호 가능
3. 기타 백업: 별도의 백업하고 주기적으로 백업을 수행할 경우 크기도 작지 않으므로 백업 방법이 많아진다.

## DeadLock

여러 개의 트랜잭션들이 실행하지 못하고 서로 무한정 기다리는 상태

1. 예방 기법: 각 트랜잭션이 실행되기 전에 필요한 모든 데이터를 로킹 해주는 법
2. 회피 기법: 자원을 할당할 때 시간 스탬프를 사용하여 교착 상태가 일어나지 않게 하도록 하는법

- Wait-Die: Ti가 Tj에 의해 로킹된 데이터를 요청할 때
  - Ti가 먼저 들어온 트랜잭션이면 기다린다(Wait)
  - Ti가 나중에 들어온 트랜잭션이면 포기(Die) 하고, 나중에 다시 요청한다.
- Wound-Wait: Ti가 Tj에 의해 로킹된 데이터를 요청할 때

  - Ti가 먼저 들어온 트랜잭션이면 데이터를 선점(Wound)한다.
  - Ti가 나중에 드러온 트랜잭션이면 기다린다.(Wait)

- 시간 스탬프 기법: 트랜잭션을 기준으로 하는 것이 아니라 각 데이터를 기준으로 하여 시간 순서대로 제어하는 방법
- 낙관적 병행 제어 기법: 트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 다 실행된 이후에 검사하여 문제가 있다면 되돌리는 방법

### 해결 방법

1. 트랜잭션 진행방향을 같은 방향으로 처리
2. 트랜잭션 처리 속도를 최소화
3. SET LOCK_TIMEOUT문을 이용하여 잠금 해제 시간을 조절

## JOIN

중복 데이터를 피하기 위해 데이터를 쪼개 여러 테이블로 나눠서 저장할 떄 분리 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서 여러 테이블을 조합한다.

### INNER JOIN

1. CROSS JOIN(교차 조인): 두 테이블을 곱 집합을 한 결과, 테이블 A와 테이블 B의 각 행을 다 조합한 결과
2. INNER JOIN(내부 조인): 조인 조건문에 따라서 2개의 (A, B) 테이블 컬럼을 합겨 새로운 테이블을 생성

- 교차 조인한 결과에 조인 조건문을 충족시키는 레코드를 반환

3. EQUI JOIN(등가 조인): 비교 기반 조인의 특정 유형으로 동등비교를 사용하는 조인
4. NON-EQUI JOIN(비등가 조인): 동등 비교를 하지 않은 조인으로 조건문이 크거나 작거나 같지 않은 경우의 비교를 사용
5. NATURAL JOIN(자연 조인): 동등 조인의 한 윻ㅇ으로 두 컬럼명이 같은 기준으로 조인 조건문이 암시적으로 일어난다.

### OUTER JOIN

INNER JOIN은 공통 컬럼명 기반으로 결과 집합을 생성했지만, 외부 조인은 조건문에 만족하지 않는 행도 표시해주는 조인

- 한 쪽에 테이블에 데이터가 없어도 조인 결과를 보여준다.

1. LEFT OUTER JOIN(왼쪽 외부 조인): 테이블 A의 모든 데이터와 테이블 B에 매칭되는 레코드를 포함하는 조인

- A는 모든 결과가 나오지만 매칭이 되지 않는 B는 나오지 않는다.
- A.id = b.id(+)
- A LEFT OUTER JOIN b ON a.id = b.id

2. RIGHT OUTER JOIN(오른쪽 외부 조인): 테이블 B의 모든 데이터와 테이블 A에 매칭되는 레코드를 포함하는 조인

- B는 모든 결과가 나오지만 매칭이 되지 않는 A는 나오지 않는다.
- A.id(+) = b.id
- A RIGHT OUTER JOIN b ON a.id = b.id

3. FULL OUTER JOIN(완전 외부 조인): MySQL에서는 명시적인 SQL 구문을 지원하지 않지만, UNION을 사용해서 완전외부 조인을 할 수 있다.

### SELF JOIN

자기 자신과 조인

### ANTI JOIN

서브 쿼리내에서 존재하지 않는 데이터만 추출하여 메인 쿼리에서 추출하는 조인

### SEMI JOIN

서브 쿼리 내에서 존재하는 데이터만 메인 쿼리에 추출하는 조인

## 스키마

데이터베이스에서 자료의 구조, 자료 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조

- 일반적으로 '스키마'라는 것은 내부 스키마를 가리킨다.
- 내부 스키마는 DBA가 만들고 데이터베이스의 전체적인 구조로써 하나만 존재해야한다.

### 외부 스키마

사용자 뷰를 가리킨다.

- 하나의 외부 스키마는 여럿 공유 가능하며
- 하나의 DB 시스템에 여러 개의 외부 스키마가 존재 가능

### 내부 스키마

시스템 프로그래머나 설계자의 관점에서 바라보는 스키마

- 데이터베이스의 물리적인 주소를 가리킴

### 개념 스키마

조직 전체의 입장, 전체적인 뷰를 가리킨다.

- 개체간의 관계의 제약조건을 나타낸다
- 데이터베이스의 접근 권한/보안/무결성 규칙에 대한 명세를 정의한다.

## SQL

### 구조

- 테이블: 데이터를 저장하는 객체로서, 데이터 모델의 상의 엔터티를 관계형 데이터베이스에서 물리적으로 구현한 것이다.
- 칼럼: 테이블의 세로 구조, 데이터 모델 상의 속성과 매칭된다.
- 행: 테이블이 가로구조, 데이터 모델 상의 인스턴스과 매칭된다.

### SQL문의 종류

- DDL: 테이블 인덱스와 같은 데이터베이스 오브젝트의 구조를 정의(생성, 변경, 삭제)하기 위한 구문
  - CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML: 테이블에 저장된 데이터 조작(조회, 입력, 수정, 삭제)하기 위한 구문
  - SELECT, INSERT, UPDATE, DELETE, MERGE
- DCL: 데이터에 대한 권한을 부여하거나 취소하기 위한 구문
  - GRANT, REVOKE
- TCL: DML문에 의한 데이터의 변경 사항을 데이터베이스에 영구히 반영하거나 취소하기 위해 트랜잭션을 제어하는 구문
  - COMMIT, ROLLBACK, SAVEPOINT

### 추가 명령문

- NVL(속성, 데이터): 속성 값이 null이 아니면 속성 값을 출력하고 null이면 데이터 값을 출력 한다.
- LENGTH(D1, A, B): D1의 문자열을 A번째 부터(1부터 시작) B개의 개수만큼 가져온다.
- LTRIM(D1, '0'): D1의 문자열을 왼쪽부터 '0'를 전부 제거하다가 다른 문자를 만나면 멈춘다.
- 올림/내림
  - FLOOR(N1): 내림
  - CEIL(N1): 올림
  - ROUND(N1): 반올림
  - TRUNC(N1, A): N1을 소수점 A번째에서 내림
- 범위 지정
  - IN(A, B): A 혹은 B인 값
    - 2개 동시 지정 방법 : (C1, C2) IN ((D11, D21), (D12, D22))
  - BETWEEN A AND B: A 초과 B 미만인 값
  - NULL값은 초과, 이상, 미만, 이하 에 어디에도 포함되지 않는다
- COUNT
  - COUNT(\*): 전체 행의 개수를 반환
  - COUNT(expr): NULL이 아닌 expr의 개수
  - COUNT(DISTINCT expr): NULL이 아는 expr 고유한 개수를 반환
- DECODE(C1, D1, E1, D2, E2): C1의 값이 D1이면 E1, D2이면 E2를 전부 반환한다.
- ORDER BY 2 = ORDER BY C2(2번째 컬럼)

### 추가 내용

- 에러: `SELECT T1.C1 FROM T1 A `
  - 별칭을 지정하고 기존 테이블 명을 사용하여 에러가 발생한다
- NULL + 다른 값 = NULL으로 출력이 된다
- 에러: `SELECT C1, C2 FROM T1 GROUP BY C1`
  - C1을 Group으로 묶었으나 C2를 그냥 출력했다(MIN/SUM/MAX/COUNT/AVG등 값으로 출력해야 한다)
- GROUP BY 한 후 SUM 값을 구하면, 고객 번호가 같은 집합 내에서 주문일자 순으로 누적 합을 출력한다.
- `SELECT A.C1, B.C2 FROM T1 A JOIN T2 B ON(A.C1 = B.C1)` 은 가능
- `SELECT A.C1, B.C2 FROM T1 A JOIN T2 B USING(C1)` 은 가능
  - USING을 쓰게 되면 공동으로 사용하게 되서 A.C1에서 오류가 발생한다.
  - `SELECT C1, B.C2 FROM T1 A JOIN T2 B USING(C1)` 으로 사용
- `SELECT * FROM T1 A RIGHT OUTER JOIN T2 B ON A.C1 = B.C1 AND B.C1 >= D`
  - B를 기준으로 왼쪽에 A의 데이터가 붙게 된다.
  - 이때, B.C1 >= D인 데이터만 붙게 된다.
  - B.C1 < D 인 데이터들은 전부 NULL값을 왼쪽에 같는다 -> 단순히 조인에 실패

### 집합 연산자

- UNION 연산(합집합): UNION, UNION ALL
- INTERSECTION 연산(교집합): INTERSECT
- DIFFERENCE 연산(차집합): EXCEPT, MINUS
- PRODUCT 연산(곱집합): CROSS JOIN
