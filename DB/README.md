# 데이터베이스

<hr>

## 데이터베이스 튜닝

데이터베이스 응용, 데이터베이스 자체, 운영체제의 조정등을 통하여 최적의 자원으로 최적의 성능을 얻을 수 있도록 개선하는 작업

1단계 - DB설계 튜닝(모델링 관점)

- 데이터베이스 설계 단계에서 성능 고려하여 설계
- 데이터 모델링, 인덱스 설계
- 데이터 파일, 데이터 스페이스 설계
- 데이터베이스 용량 산정

2단계 - DBMS 튜닝(환경관점)

- 성능을 고려하여 메모리나 블록 크기 지정
- CPU, 메모리 I/O에 관한 관점

3단계 - SQL 튜닝

- SQL 작성시 성능 고려
- Join, Indexing, SQL Exeution Plan

<hr>

## 무결성

데이터베이스에서 데이터들이 정확성, 일관성 , 유효성을 유지하는 것을 말합니다.

다양한 무결성이 존재하는 데, 몇 개의 예를 들면 Null 무결성같은 경우는 특정 속성값에 null값이 데이터가 들어갈 수 없는 무결성이고, 고유 무결성 같은 경우 특정 속성에 고유한 값을 가지는 무결성입니다 또한 개체 무결성, 기본키는 빈 값이 들어가면 안된다. 참조 무결성 서로 참조 관계에 잇는 두 테이블은 항상 일관된 값을 유지한다 등 다양한 무결성이 있습니다.

무결성이 유지되면서 DB에 저장된 값과 해당되는 실제 값이 일치하는지 신뢰할 수 있습니다.

### 무결성의 종류

1. 개체 무결성 - 즉 NULL값 허용 불가, 중복 허용 불가
2. 참조 무결성 - 외래키 값은 NULL이거나 참조 기본키값과 동일해야 함
3. 도미엔 무결성 - 특정 속성의 값이 그 속성이 정의된 도메인에 속해야 한다.
4. 고유 무결성 - 값이 중복 불가능한 속성인 경우, 그 속성 값은 모두 달라야 한다는 제약 조건
5. NULL 무결성 - NULL값이 불가능한 속성인 경우, 그 속성 값은 NULL이 들어갈 수 없다.
6. 키 무결성 - 한 테이블에는 최소한 하나의 키가 존재해야 한다는 조건

<hr>

## 트랜잭션

- 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법이다.
- 하나의 논리적인 기능을 수행하기 위한 작업의 단위로써, 데이터베스의 일관된 상태를 변환 시키는 기능을 수행합니다.

### 트랜잭션의 ACID

- 원자성 - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야한다.
- 일관성 - 트랜잭션을 수행하기 전이나 후에 데이터베이스는 항상 일관된 상태여야 한다.
- 고립성 - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성 - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### 트랜잭션 병행처리 후 문제

갱신 내용 손실 - 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우

현황 파악 오류 - 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우

모순성 - 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제

연쇄 복귀 - 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

<hr>

## 이상현상

- 삭제이상 - 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
- 삽입이상 - 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
- 수정이상 - 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일 치 현상

<hr>

## DB락의 종류

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구

공유 락 - 트랜 잭션 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

베타 락 - 트랜 잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

<hr>

## 인덱스를 사용하는 이유

추가적인 쓰기 작업과 저장 공관을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.

장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다
- 인덱스를 관리하기 위해 추가 작업이 필요하다
- 인덱스를 잘못 사용하면 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 인덱스의 자료구조

- 해시테이블
  - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
  - 시간 복잡도 라서 O(1)이라 검색이 매우 빠르다.
  - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능
- B+ Tree
  - 자식 노드가 2개 이상인 B- Tree를 개선 시킨 자료구조이다.
  - BTree의 리프노드들은 LinkedList로 연결하여 순차 검색이 용이하게 하였다.
  - 해시 테이블보다 나쁜 시간복잡도를 가졌지만 해시테이블보다 흔하게 사용된다.

### 뷰를 사용하는 이유

테이블과 유사하지만 실제 데이터가 없는 테이블을 바로보는 매개체이다. 사용자의 편의와 데이터베이스의 보안때문에 사용한다. 원본 테이블에 직접 접근하지 않아도 사용자가 임의의 뷰를 구성하여 별도의 이름을 붙이거나 접근 가능한 사람을 지정하면서 사용자가 원하는 데이터만 보여주고 보안에 있는 데이터를 보여주지 않으면서 편리하게 사용할 수 있습니다.

<hr>

## 정규화

1 - 각 컬럼들은 값이 원자값을 가지게 바꾼다.

2 - 테이블의 모든 컬럼에서 부분 함수적 종속을 제거한다.

3 - 기본키를 제외한 속성들간 이행적 함수 종속을 없앤다.

BCNF - 결정자이면서 후보키가 아닌 것들을 제거한다.

<hr>

## 관계형 데이터베이스와 비 관계형 데이터베이스의 차이점을 설명하시오

관계형 데이터베이스는 테이블로 이루어져 있으며, 이 테이블은 키와 값의 관계로 나타난다. 이처럼데이터읮 종속성을 관계로 표현하는 것이 관계형 데이터베이스 이다. 반대로, 비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히 NoSQL이라고 하며 데이터를 저장할 때 sQL 문이 아니라 다른 프로그래밍 언어를 사용한다.

### RDBMS vs NoSQL

- RDBMS
  - 2차원의 행과 열로 데이터를 관계를 관리하는 데이터베이스
  - 장점 - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
  - 단점 - 시스템이 커질 수록 퀴리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.
- NoSQL
  - RDMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
  - 장점 - NoSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리한다.
  - 단점 - 중복된 데이터가 추가 가능하며, 이에 대한 관리가 필요하다.

### RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요

NoSQL의 큰 장점은 JOIN처리가 없어서 노드 확장이 용이하다 그리고 가변적인 데이터 구조를 저장할 수 있어서 훨씬 더 유연성이 높다. 반면에 쿼리가 불가능하고 일관성을 항상 보장할 수 없다.

속도적인 면은 MySQL, ORCLE도 최적화가 잘 되어있기 때문에 상황에 따라서 뭐가 더 좋다고 설명하기는 힘들다.

### 어떤 상황에서 NoSQL을 쓰는 것이 더 적합한가?

비정형 데이터를 저장해야할 때 가장 적합다.

<hr>

## 격리수준

### 격리성 관련 문제점

1. Dirty Read - 트랜 잭션이 작업이 완료되지 않았는데도 다른 트랜 잭션에서 볼 수 있는 현상
2. Non-RepeatedRead -트랜잭션의 조회가 처음과 마지막이 다르게 나올 수 있다.
3. Phantom Read - T!이 같은 쿼리를 두번 수행시 첫번째 실행시 없던 레코드가 두번째 나오는 경우

### 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - 다른 트랜잭션이 commit한 데이터만 수정만을 허용
3. Repeatable Read - 다른 트랜잭션이 읽는 동안 삽입, 삭제 불가
4. Serializable - 다른 트랜잭션이 읽는 동안 삽입도 불가능, 동시 성능은 급격히 떨어질 수 있다.

<hr>

## Delete, Truncate, Drop

Delete(DML)

- 데이터만 삭제되며 테이블 용량이 줄어들지 않는다. 또한 데이터 삭제후 잘못된 것을 되돌릴수 있다.
- TABLE이나 CLUSTER에 행이 많으면 행이 삭제될 때마다 많은 시스템이 소모된다.
- Commit이전 롤백이 가능하다.
- 롤백 때문에 Truncate에 비해 느리다
- 전체 또는 일부만 삭제 가능
- 삭제 행수를 반환한다.

Truncate(DDL)

- 테이블을 최초 생성된 초기 상태를 만든다.
- 용량이 줄어들고, 인덱스 등도 모두 삭제된다.
- 전체 삭제만 가능한다.
- Rollback이 불가능하다.
- 삭제행수를 반환하지 않는다.

Drop(DDL)

- 기존 테이블의 존재를 제한다
- Rollback이 불가능하다
- 테이블의 정의 자체를 완전히 삭제한다.

## Connection Pool

WAS가 실행되면서 DB와 미리 Connection(연결)을 해놓은 객체들을 Pool에 저장해 두었다가 클라이언트의 요청이 오면 Connection을 빌려주고, 처리가 끝나면 Pool에 반납하는 형식

- Connection Pool에서 Connection 정보를 관리하기 때문에 DB 연결을 위한 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다

### DBCP(DataBase Connection Pool)

DB와 커넥션을 맺고 있는 객체를 관리하는 역할

- WAS가 실행되면서 Connection 객체를 미리 Pool에 생성해 둔다
- HTTP 요청에 따라 pool에서 Connection 객체를 가져다 쓰고 반환한다
- 물리적인 데이터베이스 Connection 부하를 줄이고 연결 관리한다
- Pool에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 데 드는 요청마다 연결 시간이 소비되지 않는다
- 커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수를 제한적으로 설정한다

- MIN 설정 이유: 평상시에 유지할 최소 idle의 개수
  - Connection Overhead를 프로그램을 시작할 때 한 번에 끝낸다
- MIN, MAX를 동일하게 하는 이유: 마친가지로 Connection을 계속 추가로 연결하게 되는 오버헤드를 줄이기 위해서

## 잠금

각 트랜잭션은 사용하는 데이터에 대한 엑세스를 Reservation(예약)한다

- Share Lock(공유 잠금 / Read Lock): 다른 사용자가 같이 읽는 것을 허용하지만 변경하는 것은 허용하지 않음
  - 공유 잠금끼리는 서로 충돌되지 않는다
  - 공유 잠금을 사용시, 다른 트랜잭션이 데이터를 변경할 수 없다
- Exclusive Lock(베타적 잠금 / Write Lock): 다른 사용자가 읽는 것, 변경하는 것 모두를 허용하지 않음
  - 단독잠금이 걸린 데이터는 다른 트랜잭션이 공유 잠금, 단독 잠금 또한 걸 수 없다
  - 하나의 트랜잭션만이 데이터에 대한 단독 잠금을 걸 수 있다

## 영속성 컨텍스트

엔티티를 영구 저장하는 환경

- EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있다

- 영속화 된 상태가 바로 DB에 저장되는 것이 아니다

  - commit을 하게 된다면 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날라간다

- 비영속: 영속성 컨택스트와 관계가 없는 새로운 상태
- 영속: 엔티티 매니저를 통해 엔티티가 영속성 컨텍스트에 저장되어 관리되고 있는 상태
- 준영속: 영속성 컨택스트에서 관리되다가 분리된 상태
- 삭제: 영속성 컨텍스트에서 삭제된 상태

장점

- 1차 캐시
  - 엔티티를 영속 상태로 만든 후 다시 조회하는 경우 DB 접근이 아닌 영속성 컨텍스트에서 캐시된 내용을 조회 가능
- 동일성 보장
  - 동일한 영속성 컨텍스트내에서 동일한 키로 조회한 엔티티의 경우 같은 객체
- 쓰기 지연
  - JPA가 `entityManager.persist()`를 통해서 계속 쌓고 있는 상태
    - 쓰기 지연 SQL 저장소에 쌓는다
  - `transaction.commit()`을 통해서 쓰기 지연 SQL 저장소에 있는 Query들을 DB로 날린다
    - `flush()`를 하게 된다면 1차 캐시는 지우지 않는다
    - `flush()`후에 실제 DB Transaction에 commit된다
- 변경 감지
  - 엔티티의 수정 시 따로 쿼리 조작 메서드가 필요 없음
  - Entity 데이터 수정시 update나 persisit를 통해서 영속성 컨텍스트에 해당 데이터를

### Entity Mananger

특정 작업을 위해 데이터베이스에 엑세스 하는 역할

- Entity를 DB에 등록, 조회, 수정, 삭제하는 역할
- EntityManangerFactory를 트랜잭션 단위를 수행할 때 마다 생성된다
  - EntityManagerFactory는 DB당 단 하나만 생성이 되야 한다
- 고객의 요청이 올때마다 사용했다가 닫는다
- 내부에는 영속성 컨텍스트가 있으며 이를 통해서 관리한다
- 여러 엔티티 매니저가 하나의 영속성 컨텍스트르 공유한다

- 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 절대 공유하지 않는다


### EntityTransaction

데이터를 변경하는 모든 작업은 반드시 Transaction안에서 이루어져야 한다
