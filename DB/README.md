# 데이터베이스

<hr>

## 데이터베이스 튜닝

데이터베이스 응용, 데이터베이스 자체, 운영체제의 조정등을 통하여 최적의 자원으로 최적의 성능을 얻을 수 있도록 개선하는 작업

1단계 - DB설계 튜닝(모델링 관점)

- 데이터베이스 설계 단계에서 성능 고려하여 설계
- 데이터 모델링, 인덱스 설계
- 데이터 파일, 데이터 스페이스 설계
- 데이터베이스 용량 산정

2단계 - DBMS 튜닝(환경관점)

- 성능을 고려하여 메모리나 블록 크기 지정
- CPU, 메모리 I/O에 관한 관점

3단계 - SQL 튜닝

- SQL 작성시 성능 고려
- Join, Indexing, SQL Exeution Plan

<hr>

## 무결성

데이터베이스에서 데이터들이 정확성, 일관성 , 유효성을 유지하는 것을 말합니다.

다양한 무결성이 존재하는 데, 몇 개의 예를 들면 Null 무결성같은 경우는 특정 속성값에 null값이 데이터가 들어갈 수 없는 무결성이고, 고유 무결성 같은 경우 특정 속성에 고유한 값을 가지는 무결성입니다 또한 개체 무결성, 기본키는 빈 값이 들어가면 안된다. 참조 무결성 서로 참조 관계에 잇는 두 테이블은 항상 일관된 값을 유지한다 등 다양한 무결성이 있습니다.

무결성이 유지되면서 DB에 저장된 값과 해당되는 실제 값이 일치하는지 신뢰할 수 있습니다.

### 무결성의 종류

1. 개체 무결성 - 즉 NULL값 허용 불가, 중복 허용 불가
2. 참조 무결성 - 외래키 값은 NULL이거나 참조 기본키값과 동일해야 함
3. 도미엔 무결성 - 특정 속성의 값이 그 속성이 정의된 도메인에 속해야 한다.
4. 고유 무결성 - 값이 중복 불가능한 속성인 경우, 그 속성 값은 모두 달라야 한다는 제약 조건
5. NULL 무결성 - NULL값이 불가능한 속성인 경우, 그 속성 값은 NULL이 들어갈 수 없다.
6. 키 무결성 - 한 테이블에는 최소한 하나의 키가 존재해야 한다는 조건

<hr>

## 트랜잭션

- 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법이다.
- 하나의 논리적인 기능을 수행하기 위한 작업의 단위로써, 데이터베스의 일관된 상태를 변환 시키는 기능을 수행합니다.

### 트랜잭션의 ACID

- 원자성 - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야한다.
- 일관성 - 트랜잭션을 수행하기 전이나 후에 데이터베이스는 항상 일관된 상태여야 한다.
- 고립성 - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성 - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### 트랜잭션 병행 제어

병행 제어: 동시에 여러 트랜잭션을 병행으로 처리할 때 일관성을 유지하도록 트랜잭션 간 상호 작용을 제어하는 기술

- 공유를 최대화, 시스템 활용도 최대화, 응답시간 최소화, 일관성 유지를 목적으로 한다

### 트랜잭션 병행처리 후 문제

갱신 내용 손실 - 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우

현황 파악 오류 - 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우

모순성 - 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제

연쇄 복귀 - 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

<hr>

## 이상현상

- 삭제이상 - 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
- 삽입이상 - 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
- 수정이상 - 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일 치 현상

<hr>

## DB락의 종류

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구

공유 락 - 트랜 잭션 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

베타 락 - 트랜 잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

<hr>

## 인덱스를 사용하는 이유

추가적인 쓰기 작업과 저장 공관을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.

장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다
- 인덱스를 관리하기 위해 추가 작업이 필요하다
- 인덱스를 잘못 사용하면 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 인덱스의 자료구조

- 해시테이블
  - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
  - 시간 복잡도 라서 O(1)이라 검색이 매우 빠르다.
  - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능
- B+ Tree
  - 자식 노드가 2개 이상인 B- Tree를 개선 시킨 자료구조이다.
  - BTree의 리프노드들은 LinkedList로 연결하여 순차 검색이 용이하게 하였다.
  - 해시 테이블보다 나쁜 시간복잡도를 가졌지만 해시테이블보다 흔하게 사용된다.

### 뷰를 사용하는 이유

테이블과 유사하지만 실제 데이터가 없는 테이블을 바로보는 매개체이다. 사용자의 편의와 데이터베이스의 보안때문에 사용한다. 원본 테이블에 직접 접근하지 않아도 사용자가 임의의 뷰를 구성하여 별도의 이름을 붙이거나 접근 가능한 사람을 지정하면서 사용자가 원하는 데이터만 보여주고 보안에 있는 데이터를 보여주지 않으면서 편리하게 사용할 수 있습니다.

<hr>

## 정규화

1 - 각 컬럼들은 값이 원자값을 가지게 바꾼다.

2 - 테이블의 모든 컬럼에서 부분 함수적 종속을 제거한다.

3 - 기본키를 제외한 속성들간 이행적 함수 종속을 없앤다.

BCNF - 결정자이면서 후보키가 아닌 것들을 제거한다.

<hr>

## 관계형 데이터베이스와 비 관계형 데이터베이스의 차이점을 설명하시오

관계형 데이터베이스는 테이블로 이루어져 있으며, 이 테이블은 키와 값의 관계로 나타난다. 이처럼데이터읮 종속성을 관계로 표현하는 것이 관계형 데이터베이스 이다. 반대로, 비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히 NoSQL이라고 하며 데이터를 저장할 때 sQL 문이 아니라 다른 프로그래밍 언어를 사용한다.

### RDBMS vs NoSQL

- RDBMS
  - 2차원의 행과 열로 데이터를 관계를 관리하는 데이터베이스
  - 장점 - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
  - 단점 - 시스템이 커질 수록 퀴리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.
- NoSQL
  - RDMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
  - 장점 - NoSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리한다.
  - 단점 - 중복된 데이터가 추가 가능하며, 이에 대한 관리가 필요하다.

### RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요

NoSQL의 큰 장점은 JOIN처리가 없어서 노드 확장이 용이하다 그리고 가변적인 데이터 구조를 저장할 수 있어서 훨씬 더 유연성이 높다. 반면에 쿼리가 불가능하고 일관성을 항상 보장할 수 없다.

속도적인 면은 MySQL, ORCLE도 최적화가 잘 되어있기 때문에 상황에 따라서 뭐가 더 좋다고 설명하기는 힘들다.

### 어떤 상황에서 NoSQL을 쓰는 것이 더 적합한가?

비정형 데이터를 저장해야할 때 가장 적합다.

<hr>

## 격리수준

### 격리성 관련 문제점

1. Dirty Read - 트랜 잭션이 작업이 완료되지 않았는데도 다른 트랜 잭션에서 볼 수 있는 현상
2. Non-RepeatedRead -트랜잭션의 조회가 처음과 마지막이 다르게 나올 수 있다.
3. Phantom Read - T!이 같은 쿼리를 두번 수행시 첫번째 실행시 없던 레코드가 두번째 나오는 경우

### 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - 다른 트랜잭션이 commit한 데이터만 수정만을 허용
3. Repeatable Read - 다른 트랜잭션이 읽는 동안 삽입, 삭제 불가
4. Serializable - 다른 트랜잭션이 읽는 동안 삽입도 불가능, 동시 성능은 급격히 떨어질 수 있다.

<hr>

## Delete, Truncate, Drop

Delete(DML)

- 데이터만 삭제되며 테이블 용량이 줄어들지 않는다. 또한 데이터 삭제후 잘못된 것을 되돌릴수 있다.
- TABLE이나 CLUSTER에 행이 많으면 행이 삭제될 때마다 많은 시스템이 소모된다.
- Commit이전 롤백이 가능하다.
- 롤백 때문에 Truncate에 비해 느리다
- 전체 또는 일부만 삭제 가능
- 삭제 행수를 반환한다.

Truncate(DDL)

- 테이블을 최초 생성된 초기 상태를 만든다.
- 용량이 줄어들고, 인덱스 등도 모두 삭제된다.
- 전체 삭제만 가능한다.
- Rollback이 불가능하다.
- 삭제행수를 반환하지 않는다.

Drop(DDL)

- 기존 테이블의 존재를 제한다
- Rollback이 불가능하다
- 테이블의 정의 자체를 완전히 삭제한다.

## Connection Pool

WAS가 실행되면서 DB와 미리 Connection(연결)을 해놓은 객체들을 Pool에 저장해 두었다가 클라이언트의 요청이 오면 Connection을 빌려주고, 처리가 끝나면 Pool에 반납하는 형식

- Connection Pool에서 Connection 정보를 관리하기 때문에 DB 연결을 위한 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다

### DBCP(DataBase Connection Pool)

DB와 커넥션을 맺고 있는 객체를 관리하는 역할

- WAS가 실행되면서 Connection 객체를 미리 Pool에 생성해 둔다
- HTTP 요청에 따라 pool에서 Connection 객체를 가져다 쓰고 반환한다
- 물리적인 데이터베이스 Connection 부하를 줄이고 연결 관리한다
- Pool에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 데 드는 요청마다 연결 시간이 소비되지 않는다
- 커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수를 제한적으로 설정한다

- MIN 설정 이유: 평상시에 유지할 최소 idle의 개수
  - Connection Overhead를 프로그램을 시작할 때 한 번에 끝낸다
- MIN, MAX를 동일하게 하는 이유: 마친가지로 Connection을 계속 추가로 연결하게 되는 오버헤드를 줄이기 위해서

## 잠금

각 트랜잭션은 사용하는 데이터에 대한 엑세스를 Reservation(예약)한다

- Share Lock(공유 잠금 / Read Lock): 다른 사용자가 같이 읽는 것을 허용하지만 변경하는 것은 허용하지 않음
  - 공유 잠금끼리는 서로 충돌되지 않는다
  - 공유 잠금을 사용시, 다른 트랜잭션이 데이터를 변경할 수 없다
- Exclusive Lock(베타적 잠금 / Write Lock): 다른 사용자가 읽는 것, 변경하는 것 모두를 허용하지 않음
  - 단독잠금이 걸린 데이터는 다른 트랜잭션이 공유 잠금, 단독 잠금 또한 걸 수 없다
  - 하나의 트랜잭션만이 데이터에 대한 단독 잠금을 걸 수 있다

### 비관적 락

트랜잭션이 시작될 때 Shared Lock 혹은 Exclusive Lock을 걸고 시작 하는 방법

- Write를 하기 위해서 Exclucvie Lock을 얻어야 하는데 Shared Lock이 걸려 있으면 해당 Lock을 얻지 못해 수행하지 못하고 트랜잭션이 종료된다
- 즉, 트랜잭션의 충돌이 발생할 것을 생각하여 락을 걸어둔다
- 데이터 수정할 때 특시 트랜잭션 충돌을 알 수 있다

- PESSIMISTIC_READ: 공유 락을 얻고 업데이트되거나 삭제 되지 않도록 방지
- PESSIMISTIC_WRITE: 배타적 락을 얻고 데이터를 읽거나, 업데이트, 삭제하는 것을 방지
- PESSIMISTIC_FORCE_INCREMENT: WRITE를 얻고 유사하게 작동되며, 엔티티의 버전 속성을 추가로 증가 시킨다

- 하나의 트랜잭션으로 묶어 있기 땜문에 실패를 하게 된다면 전체 Rollback이 일어난다

### 낙관적 락

DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock

- 데이터의 버전을 확인함으로써 버전이 변경된 경우에는 수정 요청을 반영하지 않는다
- 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다
- 장점
  - 성능적으로 더 효과적이다
  - 트랜잭션이 필요하지 않다
- 단점

  - 롤백하기 위해서는 수동으로 처리를 해줘야 한다

- OPTIMISTIC_FORCE_INCREEMENT: 낙관적 락을 사용하면서 버전 정보를 강제로 증가 시킨다
- Spring에서는 Entity 마다 @Version을 통해서 잠글 수 있다

- 서로 다른 종류의 데이터베이스를 업데이트하기 위해서는 낙관적 락을 사용한다

## 영속성 컨텍스트

엔티티를 영구 저장하는 환경

- EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있다

- 영속화 된 상태가 바로 DB에 저장되는 것이 아니다

  - commit을 하게 된다면 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날라간다

- JPA가 엔티티 객체들을 모아두는 공간

  - 엔티티 매니저는 관리하는 엔티티 객체들을 연속 컨텍스트에 넣어두고 객체들의 생사를 관리한다

- 비영속: 영속성 컨택스트와 관계가 없는 새로운 상태
- 영속: 엔티티 매니저를 통해 엔티티가 영속성 컨텍스트에 저장되어 관리되고 있는 상태
- 준영속: 영속성 컨택스트에서 관리되다가 분리된 상태
- 삭제: 영속성 컨텍스트에서 삭제된 상태

장점

- 1차 캐시
  - 엔티티를 영속 상태로 만든 후 다시 조회하는 경우 DB 접근이 아닌 영속성 컨텍스트에서 캐시된 내용을 조회 가능
- 동일성 보장
  - 동일한 영속성 컨텍스트내에서 동일한 키로 조회한 엔티티의 경우 같은 객체
- 쓰기 지연
  - JPA가 `entityManager.persist()`를 통해서 계속 쌓고 있는 상태
    - 쓰기 지연 SQL 저장소에 쌓는다
  - `transaction.commit()`을 통해서 쓰기 지연 SQL 저장소에 있는 Query들을 DB로 날린다
    - `flush()`를 하게 된다면 1차 캐시는 지우지 않는다
    - `flush()`후에 실제 DB Transaction에 commit된다
- 변경 감지
  - 엔티티의 수정 시 따로 쿼리 조작 메서드가 필요 없음
  - Entity 데이터 수정시 update나 persisit를 통해서 영속성 컨텍스트에 해당 데이터를

### Entity Mananger

특정 작업을 위해 데이터베이스에 엑세스 하는 역할

- Entity를 DB에 등록, 조회, 수정, 삭제하는 역할
- EntityManangerFactory를 트랜잭션 단위를 수행할 때 마다 생성된다
  - EntityManagerFactory는 DB당 단 하나만 생성이 되야 한다
- 고객의 요청이 올때마다 사용했다가 닫는다
- 내부에는 영속성 컨텍스트가 있으며 이를 통해서 관리한다
- 여러 엔티티 매니저가 하나의 영속성 컨텍스트르 공유한다

- 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 절대 공유하지 않는다

- 객체들의 Flush은 Transaction에서 관리를 하게 되고 여기서는 객체들의 생사를 관리하게 된다

### EntityTransaction

데이터를 변경하는 모든 작업은 반드시 Transaction안에서 이루어져야 한다

## Redis (REmote Dictionary Server)

비 관계형 데이터베이스, Key-Value나 컬럼, 문서 형싱의 데이터 모델이다

- 메모리 기반의 "키-값" 구조 데이터 관리 시스템이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장한다
- String, Set, Sorted Set, Hash, List의 데이터 형식을 지원한다

1. 영속성을 지원하는 인메모리 데이터 저장소
2. 읽기 성능 증대를 위한 서버 측 복제를 지원

- 실행중인 서버가 충돌하는 경우 장애 조치 처리와 함께 더 높은 읽기 성능을 지원하기 위해 슬레이브가 마스터에 연결
- 전체 데이터베이스의 초기 복사본을 받는 마스터 / 슬레이브 복제를 지원한다
- 마스터에서 쓰기가 수행되면 슬레이브 데이터 세트는 실시간으로 업데이트를 하기 위해 연결된 모든 슬레이브로 전송한다

3. 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원한다

- 파티셔닝(Partitioning)과 동일하다
- 같읕 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미한다

### 장점

1. 리스트, 배열과 같은 데이터를 처리하는데 유용하다

- value 값으로 String, Set, Sorted Set, Hash, List 등 여러 데이터 형식을 지원하기에 다양한 데이터를 활용할 수 있다.

2. 리스트형 데이터 입력과 삭제가 MySQL에 비해서 10배 정도 빠르다

- 여러 프로세서에서 동시에 같은 key에 대한 갱신을 요청할 경우, 원자성 처리로 데이터 부정합 방지 Atomic 처리함수를 제공한다

3. 메모리를 활용하면서 영속적인 데이터 보존

- 명령어로 명시적으로 삭제, expires를 설정하지 않으면 데이터를 삭제되지 않는다

4. Redis Server는 1개의 싱글 스레드로 수행되며, 따라서 서버 하나에 여러 개의 서버를 띄우는 것도 가능하다

## Hadoop

분산 환경에서 빅데이터를 저장하고 처리할 수 있는 자바 기반의 오픈소스 프레임 워크

- 하둡 소프트웨어 라이브러리는 간단한 프로그래밍 모델을 사용하여 여러 대의 컴퓨터 클러스터에 대규모 데이터 세트를 분산 처리할 수 있게 해주는 프레임 워크이다.

### 구성요소

1. 하둡 분산형 파일 시스템(HDFS)

- 하둡 네트워크 연결된 기기에 데이터를 저장하는 분산 시스템
- HDFS는 여러 기계에 대용량 파일을 나눠서 저장한다.
- 데이터를 여러 서버에 중복해서 저장함으로써 데이터 안정성을 얻는다.

  1. HDFS는 데이터를 저장하면, 다수의 노드에 복제 데이터도 함께 저장해서 데이터 유실을 막는다.
  2. HDFS에 파일을 저장하거나, 저장된 파일을 조회하려면 스트리밍 방식으로 데이터에 접근해야 한다.
  3. 한번 저장된 데이터를 수정할 수 없고 읽기만 가능해서 데이터 무결성을 유지한다.
  4. 데이터 수정은 불가능 하지만 파일 이동, 삭제, 복사할 수 있는 인터페이스르 제공한다.

  - Master/slave 구조를 통해서 하나의 네임 노드와 파일 시스템을 관리하고 클라이언트의 접근을 통제하는 마스터 서버로 구성된다.

2. 맵 리듀스(MapReduce)

- 대용량의 처리를 위한 분산 프로그래밍 모델, 소프트웨어 프레임워크
- 맵 리듀스 프레임워크를 이용하면 대규모 분산 컴퓨터 환경에서 대량의 데이터를 병렬로 분석 가능
- 프로그래머가 직접 작성하는 맵과 리듀스라는 두 개의 메소드로 구성

1. 흩어져 있는 데이터를 수직화
2. 그 데이터를 각각의 종류 별로 모은다(Map)
3. 필터링과 Sorting을 거쳐 데이터를 뽑아낸다(Reduce)

## 단일 서버 VS 서버 분리

- 단일 서버: 웹 서버 WAS + DB 서버 합쳐서
- 서버 분리: 웹 서버 WAS 따로, DB 서버 따로

- WAS에서 처리할 부분이 DB서버에 비해 상대적으로 많은 경우 분리 하게 된다

1. 확장성: Scale out하기 위해서 DB 서버 분리는 반드시 필요한 과정 중 하나이다.
2. 보안성: 별도의 데이터베이스 서버를 통해 제한적인 권한을 부여한 경우 보호 가능
3. 기타 백업: 별도의 백업하고 주기적으로 백업을 수행할 경우 크기도 작지 않으므로 백업 방법이 많아진다.
