# 데이터베이스

## 데이터베이스 튜닝

데이터베이스 응용, 데이터베이스 자체, 운영체제의 조정등을 통하여 최적의 자원으로 최적의 성능을 얻을 수 있도록 개선하는 작업

1단계 - DB설계 튜닝(모델링 관점)

- 데이터베이스 설계 단계에서 성능 고려하여 설계
- 데이터 모델링, 인덱스 설계
- 데이터 파일, 데이터 스페이스 설계
- 데이터베이스 용량 산정

2단계 - DBMS 튜닝(환경관점)

- 성능을 고려하여 메모리나 블록 크기 지정
- CPU, 메모리 I/O에 관한 관점

3단계 - SQL 튜닝

- SQL 작성시 성능 고려
- Join, Indexing, SQL Exeution Plan

## 데이터 모델링

- 모델: 일정한 표기법에 따라 표현한 모형, 축소형
- 모델링: 모델을 만들어가는 일 자체를 나타낸다.

### 모델링 3대 특징

- 단순화: 누구나 쉽게 이해할 수 있도록 표현한다
- 명확화: 명확하게 한 가지 의미로 해석되어야 한다.
- 추상화: 현실 세계를 간략하게 표현한다

## 데이터 모델

- 개념 데이터 모델: 추상화 수준이 높고, 업무 중심적으로 포괄적인 수준의 모델링
- 논리 데이터 모델: 업무에 대한 키, 속성, 관계 등을 정확하게 표현
- 물리 데이터 모델: 데이터베이스 이식을 위해, 성능, 저장 등 물리 요소를 고려하여 설계

## 엔터티

- 변별할 수 있는 사물
- 데이터베이스 내에서 변별 가능한 객체
- 정보를 저장할 수 있는 어떤 것

- 엔터티는 인스턴스의 집합이다.
- 각 인스턴스들의 성격을 구체적으로 설명하는 항목이 속성이고, 식별자는 엔터티의 여러 속성 중 각 인스턴스를 유일하게 식별할 수 있는 하나 이상의 속성을 의미한다.
- 엔터티는 영속적으로 존재하는 2개 이상의 인스턴스 집합이여야 한다.
- 속성이 존재해야 한다.
- 관계 속성은 자식 엔터티에 생성되므로 모든 엔터티에 관계 속성이 존재하지 않는다.

- 바커 표기법에서 부모 엔터티 기준으로 자식 엔터티를 필수관계로 정의할 떄 부모 쪽 관계선을 실선으로 표기한다.

### 발생 시점에 따른 분류

- 기본: 다른 엔터티와 관계에 의해 생성되지 않고 생성
- 중심: 기본 엔터티로 부터 발생됨 중심적인 역할
- 행위: 2개 이상의 부모 엔티티로 부터 발생, 자주 내용이 변경되거나 많은 데이터가 생성

## 속성

### 식별 관계

- 식별관계: 부모 엔티티의 식별자를 자식 엔티티의 식별자로 상속
  - 즉, 외래키를 이용하여 다른 테이블의 기본키로 사용하게 된다면 식별관계이다.
- 비식별관계: 일반속성으로 상속

- 실선: 식별관계
- 점선: 비식별관계

## 관계

개념 모델 단계에서 정의한 M:M 관계는 논리 모델 단계에서 관계 엔터티로 재정의 해야 한다.

- 즉, 양쪽 엔터티로부터 식별자로 상속받은 제 3의 교차 엔터티를 정의해야한다.

- 부모 엔티티 기준
  - 자식 엔터티를 필수 관계(O가 없음)로 정의한다면, 부모 인스턴스별로 자식 인스턴스를 반드시 등록한다.
  - 자식 엔터티를 선택 관계(O가 있음)로 정의한다면, 부모 인스턴스만 등록하고 자식 인스턴스를 등록하지 않아도 된다.
- 자식 엔티티 기준
  - 부모 엔터티를 필수 관계(O가 없음)로 정의한다면, 부모 인스턴스를 먼저 등록한 후에 자식 인스턴스를 등록 해야 한다.
  - 부모 엔터티를 선택 관계(O가 있음)로 정의한다면, 부모 없이 자식 인스턴스만 등록(FK에는 NULL)할 수 있다.

## 식별자

### 주 식별자의 특징

- 유일성: 엔터티의 모든 인스턴스를 고유하게 식별할 수 있어야 함
- 최소성: 고유성을 만족하는 최소의 속성으로 구성되어야 함
- 불변성: 주 식별자의 속성이 변경되지 않아야 함
- 존재성: 주 식별자의 속성에 NULL을 입력할 수 없음

### 표기법

- IE
  - 점선: 비식별관계를 표현한다
- 바커
  - 실선: 식별관계
  - 점선: 비식별관계

## 무결성

데이터베이스에서 데이터들이 정확성, 일관성 , 유효성을 유지하는 것을 말합니다.

다양한 무결성이 존재하는 데, 몇 개의 예를 들면 Null 무결성같은 경우는 특정 속성값에 null값이 데이터가 들어갈 수 없는 무결성이고, 고유 무결성 같은 경우 특정 속성에 고유한 값을 가지는 무결성입니다 또한 개체 무결성, 기본키는 빈 값이 들어가면 안된다. 참조 무결성 서로 참조 관계에 잇는 두 테이블은 항상 일관된 값을 유지한다 등 다양한 무결성이 있습니다.

무결성이 유지되면서 DB에 저장된 값과 해당되는 실제 값이 일치하는지 신뢰할 수 있습니다.

### 무결성의 종류

1. 개체 무결성 - 즉 NULL값 허용 불가, 중복 허용 불가
2. 참조 무결성 - 외래키 값은 NULL이거나 참조 기본키값과 동일해야 함
3. 도미엔 무결성 - 특정 속성의 값이 그 속성이 정의된 도메인에 속해야 한다.
4. 고유 무결성 - 값이 중복 불가능한 속성인 경우, 그 속성 값은 모두 달라야 한다는 제약 조건
5. NULL 무결성 - NULL값이 불가능한 속성인 경우, 그 속성 값은 NULL이 들어갈 수 없다.
6. 키 무결성 - 한 테이블에는 최소한 하나의 키가 존재해야 한다는 조건

## 트랜잭션

- 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법이다.
- 하나의 논리적인 기능을 수행하기 위한 작업의 단위로써, 데이터베스의 일관된 상태를 변환 시키는 기능을 수행합니다.

### 트랜잭션의 ACID

- 원자성 - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야한다.
- 일관성 - 트랜잭션을 수행하기 전이나 후에 데이터베이스는 항상 일관된 상태여야 한다.
- 고립성 - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
- 지속성 - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### 트랜잭션 병행 제어

병행 제어: 동시에 여러 트랜잭션을 병행으로 처리할 때 일관성을 유지하도록 트랜잭션 간 상호 작용을 제어하는 기술

- 공유를 최대화, 시스템 활용도 최대화, 응답시간 최소화, 일관성 유지를 목적으로 한다

### 트랜잭션 병행처리 후 문제

갱신 내용 손실 - 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우

현황 파악 오류 - 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우

모순성 - 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제

연쇄 복귀 - 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

## 이상현상

- 갱신이상: 반복된 데이터 중 일부를 갱신할 때 불일치 발생
  - 하나의 컬럼이 변경되었을 떄 관련된 모든 컬럼을 모두 변경하지 않는 경우 갱신 이상 발생
- 삽입이상: 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능
  - 1,2,3,4 속성을 넣어야 되지만 1,2,3 속성 값만 존재하여 4 속성 필드값을 결정 못하는 경우
- 삭제이상: 필요한 정보를 함꼐 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능
  - 원하는 속성값만 지우고 싶지만 컬럼을 전부 지우게 되는 경우

## DB락의 종류

- DB락 - 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구

공유 락 - 트랜 잭션 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

베타 락 - 트랜 잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

- 인덱스는 항상 최신 정렬된 상태를 유지를 해야 한다.
- INSERT: 새로운 데이터에 대한 인덱스를 추가한다.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

## 인덱스를 사용하는 이유

추가적인 쓰기 작업과 저장 공관을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.

장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다
- 인덱스를 관리하기 위해 추가 작업이 필요하다
- 인덱스를 잘못 사용하면 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 인덱스의 자료구조

- 해시테이블
  - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
  - 시간 복잡도 라서 O(1)이라 검색이 매우 빠르다.
  - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능
- B+ Tree
  - 자식 노드가 2개 이상인 B- Tree를 개선 시킨 자료구조이다.
  - BTree의 리프노드들은 LinkedList로 연결하여 순차 검색이 용이하게 하였다.
  - 해시 테이블보다 나쁜 시간복잡도를 가졌지만 해시테이블보다 흔하게 사용된다.
  - 알파벳을 기준으로 A F L 이 있다고 했을 때 B가 들어오면 A-F 사이 값이므로 A에 해당되는 인덱스로 들어가서 B라는 결과값을 가지고 온다

### 뷰를 사용하는 이유

테이블과 유사하지만 실제 데이터가 없는 테이블을 바로보는 매개체이다. 사용자의 편의와 데이터베이스의 보안때문에 사용한다. 원본 테이블에 직접 접근하지 않아도 사용자가 임의의 뷰를 구성하여 별도의 이름을 붙이거나 접근 가능한 사람을 지정하면서 사용자가 원하는 데이터만 보여주고 보안에 있는 데이터를 보여주지 않으면서 편리하게 사용할 수 있습니다.

## Sharding(샤딩)

같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미한다.

- application level, database level에서도 가능하다

### Hash Sharding

Shard Key를 이용해서 Database id를 Hashing하여 결정한다

- 각 행을 위한 고유 식별자를 생성한다는 측면에서 shard keys는 PK와 비슷하다
- 넓게 보면 정적이여야 하고 시간에 따라 바뀌면 안된다.

장점

- 데이터를 골고루 분배할 수 있고 알고리즘 적으로 분배하기 때문에 range나 directory와 다르게 모든 데이터가 어디에 위치하는지 말해주는 map이 필요 없다.

단점

- 데이터베이스에 서버를 동적으로 추가하거나 제거할 떄 어려울 수 있다.
- 서버를 추가할 때 각각의 서버는 그에 상응하는 hash value가 있어야 한다.

### Range Based Sharding

주어진 value의 범위를 기반으로 데이터를 쪼갠다.

- 데이터베이스에 어떤 브랜드의 카탈로그에 모든 정보가 있으면 몇몇 개의 shard를 만들고 가격 범위에 따라 상품 정보를 저장하게 될 수 있다.

장점

- 비교적 간단고 모든 shard들은 다른 데이터를 가지고 있고 original 데이터베이스 뿐만 아니라 서로 똑같은 스키마를 가지게 된다.
- application code는 그저 데이터가 어떤 범위인지 읽고 그에 상응하는 shard에 쓰면 된다.

단점

- 데이터베이스를 골고루 분배하지 못하기 때문에 앞서 말한 데이터베이스 hotspots가 생길 수 있다.
- 특정 데이터가 다른 데이터에 비해 더 많이 찾아질 수 있기 때문에 읽는 횟수가 불균형할 수 있다.

### Directory Based Sharding

특정 데이터를 찾을 수 있는 정적인 정보를 가지는 테이블을 가지고 있다.

- shared key가 낮은 cardinality를 가질 때 좋다. hash 함수를 거치지 않고 바로 사용할 수 있다.

장점

- 데이터를 쪼개기 위한 알고리즘 없이 바로 할당할 수 있다.

단점

- 쿼리하거나 write하기전에 lookup table을 확인해야 하므로 퍼포먼스가 떨어지게 된다.

## 정규화

1 - 각 컬럼들은 값이 원자값을 가지게 바꾼다.

2 - 테이블의 모든 컬럼에서 부분 함수적 종속을 제거한다.

3 - 기본키를 제외한 속성들간 이행적 함수 종속을 없앤다.

BCNF - 결정자이면서 후보키가 아닌 것들을 제거한다.

## 관계형 데이터베이스와 비 관계형 데이터베이스의 차이점을 설명하시오

관계형 데이터베이스는 테이블로 이루어져 있으며, 이 테이블은 키와 값의 관계로 나타난다. 이처럼데이터읮 종속성을 관계로 표현하는 것이 관계형 데이터베이스 이다. 반대로, 비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히 NoSQL이라고 하며 데이터를 저장할 때 sQL 문이 아니라 다른 프로그래밍 언어를 사용한다.

### RDBMS vs NoSQL

- RDBMS
  - 2차원의 행과 열로 데이터를 관계를 관리하는 데이터베이스
  - 장점 - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
  - 단점 - 시스템이 커질 수록 퀴리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.
- NoSQL
  - RDMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
  - 장점 - NoSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리한다.
  - 단점 - 중복된 데이터가 추가 가능하며, 이에 대한 관리가 필요하다.

### RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요

NoSQL의 큰 장점은 JOIN처리가 없어서 노드 확장이 용이하다 그리고 가변적인 데이터 구조를 저장할 수 있어서 훨씬 더 유연성이 높다. 반면에 쿼리가 불가능하고 일관성을 항상 보장할 수 없다.

속도적인 면은 MySQL, ORCLE도 최적화가 잘 되어있기 때문에 상황에 따라서 뭐가 더 좋다고 설명하기는 힘들다.

### 어떤 상황에서 NoSQL을 쓰는 것이 더 적합한가?

비정형 데이터를 저장해야할 때 가장 적합다.

## 격리수준

### 격리성 관련 문제점

1. Dirty Read - 트랜 잭션이 작업이 완료되지 않았는데도 다른 트랜 잭션에서 볼 수 있는 현상

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 발생
- 작업중인 트랜잭션2가 롤백하는 경우 트랜잭션 1은 무효가 된 데이터를 읽고 잘못된 결과를 도출

2. Non-RepeatedRead -트랜잭션의 조회가 처음과 마지막이 다르게 나올 수 있다.

- 트랜잭션 1이 데이터를 읽고 트랜잭션2가 UPDATE를 한 후에 트랜잭션 1이 다시 한번 데이터 읽는 경우
- 트랜잭션 1이 읽기 작업을 다시 한반 반복하는 경우 이전 결과와 다른 결과가 나오는 현상

3. Phantom Read - T!이 같은 쿼리를 두번 수행시 첫번째 실행시 없던 레코드가 두번째 나오는 경우

- 트랜잭션 1이 데이터를 읽고 트랜잭션2가 INSERT를 한 후에 트랜잭션 1이 다시 한번 데이터 읽는 경우
- 트랜잭션이 읽기 작업을 다시 한번 반복할 경우 이전에 없던 데이터가 나타는 현상

### 격리 수준

1. READ UNCOMMITTED
2. READ COMMITTED - 다른 트랜잭션이 commit한 데이터만 수정만을 허용

- 자신이 데이터를 읽고 있는 동안 공유락을 검, 트랜잭션 끝나기 전에도 해지 가능
- SQL Server에서 기본적인 격리 수준으로 가지고 있다.

3. Repeatable Read - 다른 트랜잭션이 읽는 동안 삽입, 삭제 불가

- 자신의 데이터에 서정된 공유락, 배타락을 트랜잭션이 종료될 떄 까지 유지하여 수정 불가능 하도록 설정

4. Serializable - 다른 트랜잭션이 읽는 동안 삽입도 불가능, 동시 성능은 급격히 떨어질 수 있다.

- 실행중인 트랜잭션은 다른 트랜잭션으로 부터 완전히 분리한다

## Delete, Truncate, Drop

Delete(DML)

- 데이터만 삭제되며 테이블 용량이 줄어들지 않는다. 또한 데이터 삭제후 잘못된 것을 되돌릴수 있다.
- TABLE이나 CLUSTER에 행이 많으면 행이 삭제될 때마다 많은 시스템이 소모된다.
- Commit이전 롤백이 가능하다.
- 롤백 때문에 Truncate에 비해 느리다
- 전체 또는 일부만 삭제 가능
- 삭제 행수를 반환한다.

Truncate(DDL)

- 테이블을 최초 생성된 초기 상태를 만든다.
- 용량이 줄어들고, 인덱스 등도 모두 삭제된다.
- 전체 삭제만 가능한다.
- Rollback이 불가능하다.
- 삭제행수를 반환하지 않는다.

Drop(DDL)

- 기존 테이블의 존재를 제한다
- Rollback이 불가능하다
- 테이블의 정의 자체를 완전히 삭제한다.

## Connection Pool

WAS가 실행되면서 DB와 미리 Connection(연결)을 해놓은 객체들을 Pool에 저장해 두었다가 클라이언트의 요청이 오면 Connection을 빌려주고, 처리가 끝나면 Pool에 반납하는 형식

- Connection Pool에서 Connection 정보를 관리하기 때문에 DB 연결을 위한 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다

### DBCP(DataBase Connection Pool)

DB와 커넥션을 맺고 있는 객체를 관리하는 역할

- WAS가 실행되면서 Connection 객체를 미리 Pool에 생성해 둔다
- HTTP 요청에 따라 pool에서 Connection 객체를 가져다 쓰고 반환한다
- 물리적인 데이터베이스 Connection 부하를 줄이고 연결 관리한다
- Pool에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 데 드는 요청마다 연결 시간이 소비되지 않는다
- 커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수를 제한적으로 설정한다

- MIN 설정 이유: 평상시에 유지할 최소 idle의 개수
  - Connection Overhead를 프로그램을 시작할 때 한 번에 끝낸다
- MIN, MAX를 동일하게 하는 이유: 마친가지로 Connection을 계속 추가로 연결하게 되는 오버헤드를 줄이기 위해서

## 잠금

각 트랜잭션은 사용하는 데이터에 대한 엑세스를 Reservation(예약)한다

- Share Lock(공유 잠금 / Read Lock): 다른 사용자가 같이 읽는 것을 허용하지만 변경하는 것은 허용하지 않음
  - 공유 잠금끼리는 서로 충돌되지 않는다
  - 공유 잠금을 사용시, 다른 트랜잭션이 데이터를 변경할 수 없다
- Exclusive Lock(베타적 잠금 / Write Lock): 다른 사용자가 읽는 것, 변경하는 것 모두를 허용하지 않음
  - 단독잠금이 걸린 데이터는 다른 트랜잭션이 공유 잠금, 단독 잠금 또한 걸 수 없다
  - 하나의 트랜잭션만이 데이터에 대한 단독 잠금을 걸 수 있다

### 비관적 락

트랜잭션이 시작될 때 Shared Lock 혹은 Exclusive Lock을 걸고 시작 하는 방법

- Write를 하기 위해서 Exclucvie Lock을 얻어야 하는데 Shared Lock이 걸려 있으면 해당 Lock을 얻지 못해 수행하지 못하고 트랜잭션이 종료된다
- 즉, 트랜잭션의 충돌이 발생할 것을 생각하여 락을 걸어둔다
- 데이터 수정할 때 특시 트랜잭션 충돌을 알 수 있다

- PESSIMISTIC_READ: 공유 락을 얻고 업데이트되거나 삭제 되지 않도록 방지
- PESSIMISTIC_WRITE: 배타적 락을 얻고 데이터를 읽거나, 업데이트, 삭제하는 것을 방지
- PESSIMISTIC_FORCE_INCREMENT: WRITE를 얻고 유사하게 작동되며, 엔티티의 버전 속성을 추가로 증가 시킨다

- 하나의 트랜잭션으로 묶어 있기 땜문에 실패를 하게 된다면 전체 Rollback이 일어난다

### 낙관적 락

DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock

- 데이터의 버전을 확인함으로써 버전이 변경된 경우에는 수정 요청을 반영하지 않는다
- 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다
- 장점
  - 성능적으로 더 효과적이다
  - 트랜잭션이 필요하지 않다
- 단점

  - 롤백하기 위해서는 수동으로 처리를 해줘야 한다

- OPTIMISTIC_FORCE_INCREEMENT: 낙관적 락을 사용하면서 버전 정보를 강제로 증가 시킨다
- Spring에서는 Entity 마다 @Version을 통해서 잠글 수 있다

- 서로 다른 종류의 데이터베이스를 업데이트하기 위해서는 낙관적 락을 사용한다

## Redis (REmote Dictionary Server)

비 관계형 데이터베이스, Key-Value나 컬럼, 문서 형싱의 데이터 모델이다

- 메모리 기반의 "키-값" 구조 데이터 관리 시스템이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장한다
- String, Set, Sorted Set, Hash, List의 데이터 형식을 지원한다

1. 영속성을 지원하는 인메모리 데이터 저장소
2. 읽기 성능 증대를 위한 서버 측 복제를 지원

- 실행중인 서버가 충돌하는 경우 장애 조치 처리와 함께 더 높은 읽기 성능을 지원하기 위해 슬레이브가 마스터에 연결
- 전체 데이터베이스의 초기 복사본을 받는 마스터 / 슬레이브 복제를 지원한다
- 마스터에서 쓰기가 수행되면 슬레이브 데이터 세트는 실시간으로 업데이트를 하기 위해 연결된 모든 슬레이브로 전송한다

3. 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원한다

- 파티셔닝(Partitioning)과 동일하다
- 같읕 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미한다

### 장점

1. 리스트, 배열과 같은 데이터를 처리하는데 유용하다

- value 값으로 String, Set, Sorted Set, Hash, List 등 여러 데이터 형식을 지원하기에 다양한 데이터를 활용할 수 있다.

2. 리스트형 데이터 입력과 삭제가 MySQL에 비해서 10배 정도 빠르다

- 여러 프로세서에서 동시에 같은 key에 대한 갱신을 요청할 경우, 원자성 처리로 데이터 부정합 방지 Atomic 처리함수를 제공한다

3. 메모리를 활용하면서 영속적인 데이터 보존

- 명령어로 명시적으로 삭제, expires를 설정하지 않으면 데이터를 삭제되지 않는다

4. Redis Server는 1개의 싱글 스레드로 수행되며, 따라서 서버 하나에 여러 개의 서버를 띄우는 것도 가능하다

## 단일 서버 VS 서버 분리

- 단일 서버: 웹 서버 WAS + DB 서버 합쳐서
- 서버 분리: 웹 서버 WAS 따로, DB 서버 따로

- WAS에서 처리할 부분이 DB서버에 비해 상대적으로 많은 경우 분리 하게 된다

1. 확장성: Scale out하기 위해서 DB 서버 분리는 반드시 필요한 과정 중 하나이다.
2. 보안성: 별도의 데이터베이스 서버를 통해 제한적인 권한을 부여한 경우 보호 가능
3. 기타 백업: 별도의 백업하고 주기적으로 백업을 수행할 경우 크기도 작지 않으므로 백업 방법이 많아진다.

## DeadLock

여러 개의 트랜잭션들이 실행하지 못하고 서로 무한정 기다리는 상태

1. 예방 기법: 각 트랜잭션이 실행되기 전에 필요한 모든 데이터를 로킹 해주는 법
2. 회피 기법: 자원을 할당할 때 시간 스탬프를 사용하여 교착 상태가 일어나지 않게 하도록 하는법

- Wait-Die: Ti가 Tj에 의해 로킹된 데이터를 요청할 때
  - Ti가 먼저 들어온 트랜잭션이면 기다린다(Wait)
  - Ti가 나중에 들어온 트랜잭션이면 포기(Die) 하고, 나중에 다시 요청한다.
- Wound-Wait: Ti가 Tj에 의해 로킹된 데이터를 요청할 때

  - Ti가 먼저 들어온 트랜잭션이면 데이터를 선점(Wound)한다.
  - Ti가 나중에 드러온 트랜잭션이면 기다린다.(Wait)

- 시간 스탬프 기법: 트랜잭션을 기준으로 하는 것이 아니라 각 데이터를 기준으로 하여 시간 순서대로 제어하는 방법
- 낙관적 병행 제어 기법: 트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 다 실행된 이후에 검사하여 문제가 있다면 되돌리는 방법

### 해결 방법

1. 트랜잭션 진행방향을 같은 방향으로 처리
2. 트랜잭션 처리 속도를 최소화
3. SET LOCK_TIMEOUT문을 이용하여 잠금 해제 시간을 조절

## JOIN

중복 데이터를 피하기 위해 데이터를 쪼개 여러 테이블로 나눠서 저장할 떄 분리 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서 여러 테이블을 조합한다.

### 테이블을 분리하는 이유

데이터베이스의 성능 개선을 위한 것이다.

- 기본적으로 테이블의 Row가 많을 수록 Index에 대한 부하가 따른다.
- 컬럼의 수가 많을 수록 I/O에 대한 부하가 걸린다.

### INNER JOIN

1. CROSS JOIN(교차 조인): 두 테이블을 곱 집합을 한 결과, 테이블 A와 테이블 B의 각 행을 다 조합한 결과
2. INNER JOIN(내부 조인): 조인 조건문에 따라서 2개의 (A, B) 테이블 컬럼을 합겨 새로운 테이블을 생성

- 교차 조인한 결과에 조인 조건문을 충족시키는 레코드를 반환

3. EQUI JOIN(등가 조인): 비교 기반 조인의 특정 유형으로 동등비교를 사용하는 조인
4. NON-EQUI JOIN(비등가 조인): 동등 비교를 하지 않은 조인으로 조건문이 크거나 작거나 같지 않은 경우의 비교를 사용
5. NATURAL JOIN(자연 조인): 동등 조인의 한 윻ㅇ으로 두 컬럼명이 같은 기준으로 조인 조건문이 암시적으로 일어난다.

### OUTER JOIN

INNER JOIN은 공통 컬럼명 기반으로 결과 집합을 생성했지만, 외부 조인은 조건문에 만족하지 않는 행도 표시해주는 조인

- 한 쪽에 테이블에 데이터가 없어도 조인 결과를 보여준다.

1. LEFT OUTER JOIN(왼쪽 외부 조인): 테이블 A의 모든 데이터와 테이블 B에 매칭되는 레코드를 포함하는 조인

- A는 모든 결과가 나오지만 매칭이 되지 않는 B는 나오지 않는다.
- A.id = b.id(+)
- A LEFT OUTER JOIN b ON a.id = b.id

2. RIGHT OUTER JOIN(오른쪽 외부 조인): 테이블 B의 모든 데이터와 테이블 A에 매칭되는 레코드를 포함하는 조인

- B는 모든 결과가 나오지만 매칭이 되지 않는 A는 나오지 않는다.
- A.id(+) = b.id
- A RIGHT OUTER JOIN b ON a.id = b.id

3. FULL OUTER JOIN(완전 외부 조인): MySQL에서는 명시적인 SQL 구문을 지원하지 않지만, UNION을 사용해서 완전외부 조인을 할 수 있다.

### SELF JOIN

자기 자신과 조인

### ANTI JOIN

서브 쿼리내에서 존재하지 않는 데이터만 추출하여 메인 쿼리에서 추출하는 조인

### SEMI JOIN

서브 쿼리 내에서 존재하는 데이터만 메인 쿼리에 추출하는 조인

## 데이터 마이그레이션

대량의 데이터를 옮기는 프로세스를 말한다.

- PC파일을 화장 하드 드라이브로 옮기는 것도 일반적이다

- 효율성이나 보안을 위해 비즈니스 기술을 업데이트 할때 사용한다.
- 구식 시스템에서 최신 기술로 이전해야 되는데 이 과정을 데이터 마이그레이션이라고 한다.

### 데이터 마이그레이션 종류

1. 스토리지 마이그레이션: 데이터를 하나의 스토리지에서 다른 스토리지로 옮기는 것을 말한다.(종이 문서를 디지털로 온라인으로 옮기는 것 포함)
2. 애플리케이션 마이그레이션: 기존 애플리케이션을 새로운 애플리케이션을 변경하는 것(구식 프로그램에서 신식 프로그램으로)
3. 데이터베이스 마이그레이션: 사무실 PC를 클라우드 기반 스토리지로 이전하는 것처럼 새로운 위치로 옮기는 것

### 데디터 마이그레이션 전력

1. 데이터의 품질 파악
2. 데이터 백업
3. 일정 파악
4. 인력 파악

## 스키마

데이터베이스에서 자료의 구조, 자료 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조

- 일반적으로 '스키마'라는 것은 내부 스키마를 가리킨다.
- 내부 스키마는 DBA가 만들고 데이터베이스의 전체적인 구조로써 하나만 존재해야한다.

### 외부 스키마

사용자 뷰를 가리킨다.

- 하나의 외부 스키마는 여럿 공유 가능하며
- 하나의 DB 시스템에 여러 개의 외부 스키마가 존재 가능

### 내부 스키마

시스템 프로그래머나 설계자의 관점에서 바라보는 스키마

- 데이터베이스의 물리적인 주소를 가리킴

### 개념 스키마

조직 전체의 입장, 전체적인 뷰를 가리킨다.

- 개체간의 관계의 제약조건을 나타낸다
- 데이터베이스의 접근 권한/보안/무결성 규칙에 대한 명세를 정의한다.

## SQL

### 구조

- 테이블: 데이터를 저장하는 객체로서, 데이터 모델의 상의 엔터티를 관계형 데이터베이스에서 물리적으로 구현한 것이다.
- 칼럼: 테이블의 세로 구조, 데이터 모델 상의 속성과 매칭된다.
- 행: 테이블이 가로구조, 데이터 모델 상의 인스턴스과 매칭된다.

### SQL문의 종류

- DDL: 테이블 인덱스와 같은 데이터베이스 오브젝트의 구조를 정의(생성, 변경, 삭제)하기 위한 구문
  - CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML: 테이블에 저장된 데이터 조작(조회, 입력, 수정, 삭제)하기 위한 구문
  - SELECT, INSERT, UPDATE, DELETE, MERGE
- DCL: 데이터에 대한 권한을 부여하거나 취소하기 위한 구문
  - GRANT, REVOKE
- TCL: DML문에 의한 데이터의 변경 사항을 데이터베이스에 영구히 반영하거나 취소하기 위해 트랜잭션을 제어하는 구문
  - COMMIT, ROLLBACK, SAVEPOINT

### 추가 명령문

- NVL(속성, 데이터): 속성 값이 null이 아니면 속성 값을 출력하고 null이면 데이터 값을 출력 한다.
- LENGTH(D1, A, B): D1의 문자열을 A번째 부터(1부터 시작) B개의 개수만큼 가져온다.
- LTRIM(D1, '0'): D1의 문자열을 왼쪽부터 '0'를 전부 제거하다가 다른 문자를 만나면 멈춘다.
- 올림/내림
  - FLOOR(N1): 내림
  - CEIL(N1): 올림
  - ROUND(N1): 반올림
  - TRUNC(N1, A): N1을 소수점 A번째에서 내림
- 범위 지정
  - IN(A, B): A 혹은 B인 값
    - 2개 동시 지정 방법 : (C1, C2) IN ((D11, D21), (D12, D22))
  - BETWEEN A AND B: A 초과 B 미만인 값
  - NULL값은 초과, 이상, 미만, 이하 에 어디에도 포함되지 않는다
- COUNT
  - COUNT(\*): 전체 행의 개수를 반환
  - COUNT(expr): NULL이 아닌 expr의 개수
  - COUNT(DISTINCT expr): NULL이 아는 expr 고유한 개수를 반환
- DECODE(C1, D1, E1, D2, E2): C1의 값이 D1이면 E1, D2이면 E2를 전부 반환한다.
- ORDER BY 2 = ORDER BY C2(2번째 컬럼)
- NULLIF(C1, C2): C1 == C2 이면 NULL, 같으면 C1을 반환 한다
- RANK
  - RANK() OVER(ORDER BY C1 ASC/DESC) RANK등수: C1을 순서대로 정렬하여 출력한다.
    - 중복 순위 다음 값은 중보 개수 만큼 떨어진 순위로 출력하도록 한다.
  - DENSE RANK() OVER(ORDER BY C1 ASC/DESC) RANK등수: C1을 순서대로 정렬하여 출력한다.
    - 중복 순위 다음 값에 대해서는 중복 값 개수와 상관 없이 순차적인 순위 값을 출력하도록 한다.
  - ROW_NUMBER() OVER(ORDER BY C1 ASC/DESC) RANK등수: C1을 순서대로 정렬하여 출력한다.
    - 중복값들에 대해서도 순차적인 표시하도록 한다.
  - TOP(N): N개의 상위 데이터를 보여준다
    - RANK와 같은 내용을 처리한 후에 보여준다.
    - FETCH FIRST N ROWS ONLY와 같다
- PAD
  - LPAD(A, LEN, T): A에 T값을 왼쪽 부터 추가 하여 총 길이를 LEN으로 만든다.
  - RPAD(A, LEN, T): A에 T값을 오른쪽 부터 추가 하여 총 길이를 LEN으로 만든다.
- ROLL UP
  - GROUP BY를 사용 한 후에 그룹별로 묶어서 SUM 결과를 보여준다.
  - ROLL UP(C1, C2): C1에 대한 그룹을 보여주고 (C1, C2) 에 대한 그룹을 보여준다.
- CUDE: ROLL UP과 반대로 위에 결과를 보여준다
- GROUPING SETS: 지정한 행 그룹으로 행을 집계한다.
- SUM(C1) OVER(ORDER BY C1): C1을 기준으로 정렬된 테이블에서 C1의 누적합들을 보여준다.
  - 단, 동일한 값의 행이 있다면 전부 더하고 통일 시킨다(RANGE UNBOUNDED PRECEDING)
- RANGE BEWTEEN A PRECEDING AND B FOLLOWING: 각 행에서 A값을 제외하고 B을 더한 값을 윈도우로 지정하라는 의미이다.
  - X값이 있으면 X - A 부터 X + B 까지 윈도우 범위가 된다
- CONNECT BY: 증가하거나 감소하는 데이터를 동적으로 생성할 때 사용한다.
  - 계층 전개 시 평가되므로 선택되는 하위 노드에 영향을 미친다.
  - CONNECT BY가 실행되고 난 후 WHERE이 실행이 된다.
- CONNECT_BY_ISLEFT: 리프노드이면 1 아니면 0
- PRIOR: 직전 상위 노드의 값을 반환한다.
- WITH: UNION ALL 연산자로 다 합쳐서 구성이 된다.
- PIVOT: 행을 열로 바꿔서 그룹함수를 이용하 사용한다
  - PIVOT(FOR = PIVOT할 열을 지정, IN - PIVOT할 열을 지정)
  - 집계 함수와 IN 절에 지정한 별칭에 따라서 `SUM (C1) AS D1`으로 지정하면 D1_C1의 값이 된다.
  - UNPIVOT할 때 별칭을 지정하지 않으면 D1_C1 그래도 돌아간다.
    - UNPIVOT할 때 INCLUDE NULL을 하게 되면 데이터가 없더라도 NULL을 출력한다.
- REGEXP_SUBSTR(C1, A): C1에서 A와 일치하는 패턴만 출력하게 된다.
  - ?: 탐욕적으로 최대
  - .: 모든 문자
  - +: 1회 또는 그 이상의 횟수로 일치
  - $: 문자열 끝을 의미한다.
  - \n: n번째 서브 표현식과 일치?
- REGEXP_REPLACE(C, D, E): C 안에서 D와 일치한 패턴을 D로 변경한다. 없으면 제거한다.
- LAG: 현재 행에서 offset 이전의 행의 칼럼값을 반환한다. 기본값은 1이고 이전행이 없으면 NULL, 혹은 지정 값을 반환한다.
- LEAD: 다음 값들
- UNLIMITED TABLESPACE: 모든 테이블 스페이스에게 무제한 권한 부여
- GRANT ALL(ALTER, INDEX, REFERENCES) ON T1 TO U1
- CREATE ROLL: 롤 생성 가능
- EXTRACT(MONTH FROM C1): 월 데이터를 가져오나 0를 보간하지 않는다.
- TRIM("문자열"): 양쪽 공백 스페이스마를 제거한다.

  - LTRIM: 왼쪽만
  - RTRIM: 오른쪽만

- CHAR: 고정 길이 저장, ALTER 축소 불가능
- VARCHAR: 가변 길이 저장, ALTER 축소 가능, NULL 허용은 반대로만 가능하다

### 추가 내용

- 에러: `SELECT T1.C1 FROM T1 A `
  - 별칭을 지정하고 기존 테이블 명을 사용하여 에러가 발생한다
- NULL + 다른 값 = NULL으로 출력이 된다
- 에러: `SELECT C1, C2 FROM T1 GROUP BY C1`
  - C1을 Group으로 묶었으나 C2를 그냥 출력했다(MIN/SUM/MAX/COUNT/AVG등 값으로 출력해야 한다)
- GROUP BY 한 후 SUM 값을 구하면, 고객 번호가 같은 집합 내에서 주문일자 순으로 누적 합을 출력한다.
- `SELECT A.C1, B.C2 FROM T1 A JOIN T2 B ON(A.C1 = B.C1)` 은 가능
- `SELECT A.C1, B.C2 FROM T1 A JOIN T2 B USING(C1)` 은 가능
  - USING을 쓰게 되면 공동으로 사용하게 되서 A.C1에서 오류가 발생한다.
  - `SELECT C1, B.C2 FROM T1 A JOIN T2 B USING(C1)` 으로 사용
- `SELECT * FROM T1 A RIGHT OUTER JOIN T2 B ON A.C1 = B.C1 AND B.C1 >= D`
  - B를 기준으로 왼쪽에 A의 데이터가 붙게 된다.
  - 이때, B.C1 >= D인 데이터만 붙게 된다.
  - B.C1 < D 인 데이터들은 전부 NULL값을 왼쪽에 같는다 -> 단순히 조인에 실패
- NATURAL JOIN을 하게 되는 경우 조인에 사용된 열은 식별자를 사용할 수 없다.
- 시간 계산
  - 1/24: 1시간
  - 1/24/60: 1분
  - 1.5/24: 1시간 반
  - 1/24/60/60: 1초
- 조건 우선순위
  - 1. 연산자
  - 2. 비교조건
  - 3. IN, LIKE, BEWTEEN, NULL
  - 4. NOT
  - 5. AND
  - 6. OR
- MIN(VARCHAR): 숫자일 경우도 문자열로 취급하여 앞에 가장 작은 숫자가 최소 값이 들어간다.
- `WHERE B.C1(+) = A.C1 AND B.C2 <= 2` 에서는 OUTER JOIN이 되어야 하지만 뒤의 B.C2에는 (+)가 없어서 INNER JOIN으로 변경된다.
- `SELECT 1` - 해당 테이블의 갯수만큼 1로된 행을 출력한다
  - 여기서 1은 TRUE를 의미한다.
- ```
    C1 NOT (1, NULL)
  = NOT(C1 = 1 OR C1 = NULL)
  = C1 <> 1 AND C1 <> NULL
  = C1 <> 1 AND NULL
  ```
- 테이블의 특수 문자 허용 `#, $, _`
- DDL문은 암시적으로 Commit를 수행 한다.
- NUMBER 타입은 이미 값을 하나라도 입력한 경우 데이터 타입의 크기를 축소할 수 없다.
- Unique값이 있더라도 NULL은 따로따로 데이터를 넣을 수 있다.
- 오라클은 Lock을 기다린다

### 처리 순서

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

### 집합 연산자

- UNION 연산(합집합): UNION, UNION ALL
- INTERSECTION 연산(교집합): INTERSECT
- DIFFERENCE 연산(차집합): EXCEPT, MINUS
- PRODUCT 연산(곱집합): CROSS JOIN
